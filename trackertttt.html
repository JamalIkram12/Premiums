<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptocurrency Screener</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #0f1525;
            color: #e0e0ff;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 4100px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #2a3a5a;
        }
        
        h1 {
            color: #6c8af5;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #8a9bb8;
            font-size: 1.1rem;
        }
        
        .current-timeframe {
            color: #6c8af5;
            font-weight: bold;
            margin-left: 5px;
        }
        
        .last-updated {
            text-align: right;
            margin-bottom: 15px;
            color: #6c8af5;
            font-size: 0.9rem;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .symbol-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .view-btn {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #a0b0f0;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .view-btn.active {
            background-color: #3a4a8a;
            border-color: #6c8af5;
            color: #ffffff;
        }
        
        .view-btn:hover {
            background-color: #2a3a5a;
        }
        
        .timeframe-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            font-size: 0.9rem;
            color: #8a9bb8;
        }
        
        .control-group select {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #e0e0ff;
            padding: 6px 10px;
            border-radius: 4px;
            min-width: 100px;
        }
        
        .refresh-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .refresh-btn {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #a0b0f0;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .refresh-btn:hover {
            background-color: #2a3a5a;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #4caf50;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* Filter Panel Styles */
        .filter-panel-container {
            margin-bottom: 20px;
            border-radius: 10px;
            border: 1px solid #2a3a5a;
            background-color: #121a2d;
            overflow: hidden;
        }
        
        .filter-panel-header {
            background-color: #1a2238;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #2a3a5a;
        }
        
        .filter-panel-header:hover {
            background-color: #2a3a5a;
        }
        
        .filter-panel-header h3 {
            color: #6c8af5;
            font-size: 1.1rem;
        }
        
        .filter-panel-header i {
            transition: transform 0.3s ease;
        }
        
        .filter-panel-header i.rotated {
            transform: rotate(180deg);
        }
        
        .filter-panel {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .filter-panel.collapsed {
            display: none;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .filter-group label {
            font-size: 0.9rem;
            color: #8a9bb8;
            font-weight: 500;
        }
        
        .filter-select {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #e0e0ff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            width: 100%;
            cursor: pointer;
        }
        
        .filter-select:hover {
            border-color: #3a4a8a;
        }
        
        .filter-select:focus {
            outline: none;
            border-color: #6c8af5;
        }
        
        .filter-actions {
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
            padding-top: 10px;
            border-top: 1px solid #2a3a5a;
        }
        
        .filter-btn {
            background-color: #1a2238;
            border: 1px solid #2a3a5a;
            color: #a0b0f0;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        
        .filter-btn:hover {
            background-color: #2a3a5a;
        }
        
        .filter-btn.primary {
            background-color: #3a4a8a;
            border-color: #6c8af5;
            color: #ffffff;
        }
        
        .filter-btn.primary:hover {
            background-color: #4a5a9a;
        }
        
        .active-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .active-filter-tag {
            background-color: #2a3a5a;
            color: #a0b0f0;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .active-filter-tag i {
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .active-filter-tag i:hover {
            color: #f44336;
        }
        
        .clear-filters-btn {
            background-color: transparent;
            border: 1px solid #2a3a5a;
            color: #8a9bb8;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .clear-filters-btn:hover {
            background-color: #2a3a5a;
            color: #e0e0ff;
        }
        
        .filter-results {
            color: #8a9bb8;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        
        .table-container {
            overflow-x: auto;
            border-radius: 10px;
            border: 1px solid #2a3a5a;
            background-color: #121a2d;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 4100px;
        }
        
        thead {
            background-color: #1a2238;
        }
        
        th {
            padding: 18px 15px;
            text-align: left;
            color: #6c8af5;
            font-weight: 600;
            border-bottom: 1px solid #2a3a5a;
        }
        
        th i {
            margin-right: 8px;
        }
        
        td {
            padding: 16px 15px;
            border-bottom: 1px solid #2a3a5a;
        }
        
        tbody tr:last-child td {
            border-bottom: none;
        }
        
        tbody tr:hover {
            background-color: #1a2238;
        }
        
        .crypto-name {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .watchlist-star {
            color: #8a9bb8;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s;
            min-width: 24px;
            display: inline-block;
        }
        
        .watchlist-star:hover {
            color: #ffc107;
            transform: scale(1.2);
        }
        
        .watchlist-star.active {
            color: #ffc107;
        }
        
        .watchlist-star.active:hover {
            color: #ff9800;
        }
        
        .crypto-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: #2a3a5a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .btc { background-color: #f7931a; color: #000; }
        .eth { background-color: #627eea; color: #fff; }
        .ada { background-color: #0033ad; color: #fff; }
        .xrp { background-color: #23292f; color: #fff; }
        .avax { background-color: #e84142; color: #fff; }
        
        .crypto-link {
            color: #e0e0ff;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-block;
            padding: 2px 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .crypto-link:hover {
            color: #6c8af5;
            background-color: rgba(108, 138, 245, 0.1);
            text-decoration: underline;
        }
        
        .crypto-link i {
            margin-right: 5px;
            font-size: 0.9rem;
            color: #6c8af5;
        }
        
        .price {
            font-weight: 700;
            font-size: 1.2rem;
            transition: color 0.5s ease;
        }
        
        .price.up {
            color: #4caf50;
        }
        
        .price.down {
            color: #f44336;
        }
        
        .price.neutral {
            color: #e0e0ff;
        }
        
        .price-change {
            font-size: 0.9rem;
            margin-top: 4px;
        }
        
        .swing-pattern-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .pattern-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .higher-high {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }
        
        .lower-low {
            background-color: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        
        .consolidation {
            background-color: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        
        .swing-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .swing-price {
            font-weight: 600;
            color: #e0e0ff;
        }
        
        .percentage {
            font-weight: 600;
            color: #6c8af5;
        }
        
        .macd-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .macd-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .macd-positive {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }
        
        .macd-negative {
            background-color: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        
        .macd-neutral {
            background-color: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        
        .macd-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .crossover-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .crossover-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .bullish-crossover {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .bearish-crossover {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .no-crossover {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .volume-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .volume-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .volume-spike {
            background-color: rgba(155, 81, 224, 0.3);
            color: #9b51e0;
            border: 1px solid rgba(155, 81, 224, 0.5);
        }
        
        .volume-normal {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .volume-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .atr-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .atr-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .atr-high {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .atr-moderate {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .atr-good {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .atr-low {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .atr-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .obv-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .obv-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .obv-rising {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .obv-falling {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .obv-neutral {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .obv-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .ichimoku-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .ichimoku-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .ichimoku-above {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .ichimoku-below {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .ichimoku-inside {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .ichimoku-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .ema-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .ema-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .ema-above {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .ema-below {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .ema-cross {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .ema-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .correlation-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .correlation-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .correlation-low {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .correlation-medium {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .correlation-high {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .correlation-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .support-levels-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .support-levels-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .support-levels-active {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .support-levels-none {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .support-levels-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .flipped-support-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .flipped-support-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .flipped-support-active {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .flipped-support-none {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .flipped-support-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        /* NEW LIQUIDITY GRAB SUPPORT INDICATOR STYLES */
        .liquidity-grab-support-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .liquidity-grab-support-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .liquidity-grab-support-yes {
            background-color: rgba(0, 150, 255, 0.3);
            color: #0096ff;
            border: 1px solid rgba(0, 150, 255, 0.5);
        }
        
        .liquidity-grab-support-no {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .liquidity-grab-support-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .resistance-levels-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .resistance-levels-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .resistance-levels-active {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .resistance-levels-none {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .resistance-levels-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .flipped-resistance-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .flipped-resistance-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .flipped-resistance-active {
            background-color: rgba(155, 81, 224, 0.3);
            color: #9b51e0;
            border: 1px solid rgba(155, 81, 224, 0.5);
        }
        
        .flipped-resistance-none {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .flipped-resistance-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        /* NEW LIQUIDITY GRAB RESISTANCE INDICATOR STYLES */
        .liquidity-grab-resistance-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .liquidity-grab-resistance-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .liquidity-grab-resistance-yes {
            background-color: rgba(255, 87, 34, 0.3);
            color: #ff5722;
            border: 1px solid rgba(255, 87, 34, 0.5);
        }
        
        .liquidity-grab-resistance-no {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .liquidity-grab-resistance-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .cpr-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .cpr-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .cpr-above {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .cpr-below {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .cpr-inside {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .cpr-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .cpr-level-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(26, 34, 56, 0.7);
            border-radius: 4px;
            border-left: 3px solid;
            font-size: 0.8rem;
            margin-bottom: 3px;
        }
        
        .cpr-tc {
            border-left-color: #9b51e0;
        }
        
        .cpr-cp {
            border-left-color: #6c8af5;
        }
        
        .cpr-bc {
            border-left-color: #4caf50;
        }
        
        .support-convergence-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .support-convergence-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .support-convergence-yes {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .support-convergence-no {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .support-convergence-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        /* NEW RESISTANCE CONVERGENCE INDICATOR STYLES */
        .resistance-convergence-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .resistance-convergence-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .resistance-convergence-yes {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .resistance-convergence-no {
            background-color: rgba(100, 100, 100, 0.2);
            color: #8a9bb8;
        }
        
        .resistance-convergence-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .convergence-price {
            font-weight: 600;
            color: #ffc107;
            font-family: 'Courier New', monospace;
        }
        
        /* VWAP Indicator Styles */
        .vwap-indicator {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .vwap-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .vwap-above {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .vwap-below {
            background-color: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .vwap-near {
            background-color: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .vwap-details {
            font-size: 0.85rem;
            color: #8a9bb8;
            line-height: 1.4;
        }
        
        .vwap-band-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(26, 34, 56, 0.7);
            border-radius: 4px;
            border-left: 3px solid;
            font-size: 0.8rem;
            margin-bottom: 3px;
        }
        
        .vwap-upper {
            border-left-color: #f44336;
        }
        
        .vwap-line {
            border-left-color: #6c8af5;
        }
        
        .vwap-lower {
            border-left-color: #4caf50;
        }
        
        /* UPDATED INDICATOR SUMMARY STYLES - THREE COLUMNS */
        .indicator-summary-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 180px;
            max-width: 200px;
        }
        
        .indicator-summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(26, 34, 56, 0.7);
            border-radius: 6px;
            font-size: 0.85rem;
            border-left: 4px solid transparent;
        }
        
        .indicator-summary-label {
            color: #8a9bb8;
            font-weight: 500;
            min-width: 100px;
        }
        
        .indicator-summary-value {
            font-weight: 600;
            text-align: right;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        /* Color coding for indicator values */
        .summary-positive {
            color: #4caf50 !important; /* Green for bullish/positive */
        }
        
        .summary-negative {
            color: #f44336 !important; /* Red for bearish/negative */
        }
        
        .summary-neutral {
            color: #ffc107 !important; /* Yellow for neutral */
        }
        
        .summary-info {
            color: #6c8af5 !important; /* Blue for informational */
        }
        
        .summary-highlight {
            background: rgba(108, 138, 245, 0.1);
            border-left-color: #6c8af5;
        }
        
        /* Border colors for different indicator types */
        .summary-macd { border-left-color: #4caf50; }
        .summary-crossover { border-left-color: #9b51e0; }
        .summary-volume { border-left-color: #ff9800; }
        .summary-atr { border-left-color: #f44336; }
        .summary-obv { border-left-color: #2196f3; }
        .summary-ichimoku { border-left-color: #00bcd4; }
        .summary-ema { border-left-color: #ffc107; }
        .summary-support { border-left-color: #4caf50; }
        .summary-flipped { border-left-color: #ffc107; }
        .summary-resistance { border-left-color: #f44336; }
        .summary-flipped-resistance { border-left-color: #9b51e0; }
        .summary-cpr { border-left-color: #9b51e0; }
        .summary-vwap { border-left-color: #9c27b0; }
        .summary-correlation { border-left-color: #3f51b5; }
        .summary-convergence { border-left-color: #4caf50; }
        .summary-resistance-convergence { border-left-color: #f44336; }
        .summary-liquidity-support { border-left-color: #0096ff; }
        .summary-liquidity-resistance { border-left-color: #ff5722; }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #8a9bb8;
        }
        
        .loading-spinner {
            border: 3px solid #2a3a5a;
            border-top: 3px solid #6c8af5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            color: #f44336;
            background-color: rgba(244, 67, 54, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            display: none;
        }
        
        .error.show {
            display: block;
        }
        
        .info-note {
            margin-top: 20px;
            padding: 15px;
            background-color: #1a2238;
            border-radius: 8px;
            border-left: 4px solid #6c8af5;
            font-size: 0.9rem;
            color: #8a9bb8;
        }
        
        .watchlist-count {
            display: inline-block;
            background-color: #6c8af5;
            color: white;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.8rem;
            margin-left: 5px;
        }
        
        .app-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(15, 21, 37, 0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .app-modal-content {
            background-color: #1a2238;
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #2a3a5a;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        
        .app-modal h3 {
            color: #6c8af5;
            margin-bottom: 15px;
        }
        
        .app-modal p {
            margin-bottom: 20px;
            color: #8a9bb8;
        }
        
        .app-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .app-modal-btn {
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .app-modal-btn.primary {
            background-color: #6c8af5;
            color: white;
            border: none;
        }
        
        .app-modal-btn.secondary {
            background-color: transparent;
            color: #8a9bb8;
            border: 1px solid #2a3a5a;
        }
        
        .app-modal-btn:hover {
            opacity: 0.9;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #2a3a5a;
            color: #8a9bb8;
            font-size: 0.9rem;
        }
        
        .progress-bar-container {
            width: 100%;
            background-color: #2a3a5a;
            border-radius: 10px;
            overflow: hidden;
            height: 8px;
            margin-top: 5px;
        }
        
        .progress-bar {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
        }
        
        .progress-bar.low {
            background-color: #4caf50;
        }
        
        .progress-bar.medium {
            background-color: #ffc107;
        }
        
        .progress-bar.high {
            background-color: #f44336;
        }
        
        .level-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(26, 34, 56, 0.7);
            border-radius: 6px;
            border-left: 3px solid;
            font-size: 0.8rem;
            margin-bottom: 4px;
        }
        
        .support-level {
            border-left-color: #4caf50;
        }
        
        .flipped-level {
            border-left-color: #ffc107;
        }
        
        .resistance-level {
            border-left-color: #f44336;
        }
        
        .flipped-resistance-level {
            border-left-color: #9b51e0;
        }
        
        .level-price {
            font-weight: 600;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }
        
        .level-percent {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }
        
        .percent-positive {
            background: rgba(76, 175, 129, 0.2);
            color: #4caf50;
        }
        
        .percent-negative {
            background: rgba(239, 68, 68, 0.2);
            color: #f44336;
        }
        
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
            
            .timeframe-controls {
                justify-content: center;
            }
            
            .refresh-controls {
                justify-content: center;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            th, td {
                padding: 12px 10px;
            }
            
            .app-modal-buttons {
                flex-direction: column;
            }
            
            .indicator-summary-container {
                min-width: 150px;
            }
            
            .indicator-summary-label {
                min-width: 80px;
                font-size: 0.8rem;
            }
            
            .indicator-summary-value {
                font-size: 0.8rem;
            }
            
            .filter-panel {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 10px;
                padding: 15px;
            }
            
            .filter-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-chart-line"></i> Cryptocurrency Screener</h1>
            <p class="subtitle">Real-time price data with comprehensive technical analysis for major cryptocurrencies <span class="current-timeframe">(1 Hour Timeframe)</span></p>
        </header>
        
        <div class="last-updated">
            Last updated: <span id="last-updated-time">--:--:--</span>
            <div id="watchlist-count-display" style="display: inline-block; margin-left: 15px; color: #ffc107;">
                <i class="fas fa-star"></i> <span id="watchlist-count">0</span> in watchlist
            </div>
        </div>
        
        <div class="controls">
            <div class="symbol-selector">
                <button class="view-btn active" id="view-all-btn">
                    <i class="fas fa-coins"></i> All Coins
                </button>
                <button class="view-btn" id="view-watchlist-btn">
                    <i class="fas fa-star"></i> Watchlist <span class="watchlist-count" id="watchlist-badge">0</span>
                </button>
            </div>
            
            <div class="timeframe-controls">
                <div class="control-group">
                    <label for="timeframe-select"><i class="fas fa-clock"></i> Timeframe:</label>
                    <select id="timeframe-select">
                        <option value="1h">1 Hour</option>
                        <option value="4h">4 Hour</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="ema-period"><i class="fas fa-wave-square"></i> EMA Period:</label>
                    <select id="ema-period">
                        <option value="9">9 Period</option>
                        <option value="20" selected>20 Period</option>
                        <option value="50">50 Period</option>
                        <option value="100">100 Period</option>
                        <option value="200">200 Period</option>
                    </select>
                </div>
            </div>
            
            <div class="refresh-controls">
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span>Live Data</span>
                </div>
                <button class="refresh-btn" id="refresh-data">
                    <i class="fas fa-sync-alt"></i> Refresh Data
                </button>
            </div>
        </div>
        
        <!-- Filter Panel -->
        <div class="filter-panel-container">
            <div class="filter-panel-header" id="filter-panel-toggle">
                <h3><i class="fas fa-filter"></i> Filter Options</h3>
                <i class="fas fa-chevron-down" id="filter-panel-icon"></i>
            </div>
            <div class="filter-panel" id="filter-panel">
                <div class="filter-group">
                    <label for="filter-macd">MACD</label>
                    <select id="filter-macd" class="filter-select">
                        <option value="all">All</option>
                        <option value="Positive">Positive</option>
                        <option value="Negative">Negative</option>
                        <option value="Neutral">Neutral</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-crossover">MACD Crossover</label>
                    <select id="filter-crossover" class="filter-select">
                        <option value="all">All</option>
                        <option value="Bullish Crossover">Bullish Crossover</option>
                        <option value="Bearish Crossover">Bearish Crossover</option>
                        <option value="None">No Crossover</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-volume">Volume Spike</label>
                    <select id="filter-volume" class="filter-select">
                        <option value="all">All</option>
                        <option value="Spike">Spike</option>
                        <option value="Normal">Normal</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-atr">Volatility ATR</label>
                    <select id="filter-atr" class="filter-select">
                        <option value="all">All</option>
                        <option value="High">High</option>
                        <option value="Good">Good</option>
                        <option value="Moderate">Moderate</option>
                        <option value="Low">Low</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-obv">OBV</label>
                    <select id="filter-obv" class="filter-select">
                        <option value="all">All</option>
                        <option value="Rising Volume">Rising Volume</option>
                        <option value="Declining Volume">Declining Volume</option>
                        <option value="None">None</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-ichimoku">Ichimoku Cloud</label>
                    <select id="filter-ichimoku" class="filter-select">
                        <option value="all">All</option>
                        <option value="Above Cloud">Above Cloud</option>
                        <option value="Below Cloud">Below Cloud</option>
                        <option value="Inside Cloud">Inside Cloud</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-ema">EMA</label>
                    <select id="filter-ema" class="filter-select">
                        <option value="all">All</option>
                        <option value="Above EMA">Above EMA</option>
                        <option value="Below EMA">Below EMA</option>
                        <option value="Near EMA">Near EMA</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-correlation">Correlation with BTC</label>
                    <select id="filter-correlation" class="filter-select">
                        <option value="all">All</option>
                        <option value="High">High</option>
                        <option value="Medium">Medium</option>
                        <option value="Low">Low</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-support">Support Level</label>
                    <select id="filter-support" class="filter-select">
                        <option value="all">All</option>
                        <option value="No Support">No Support</option>
                        <option value="Has Support">Has Support</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-flipped-support">Flipped Support</label>
                    <select id="filter-flipped-support" class="filter-select">
                        <option value="all">All</option>
                        <option value="No Flipped Support">No Flipped Support</option>
                        <option value="Has Flipped Support">Has Flipped Support</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-resistance">Resistance Level</label>
                    <select id="filter-resistance" class="filter-select">
                        <option value="all">All</option>
                        <option value="No Resistance">No Resistance</option>
                        <option value="Has Resistance">Has Resistance</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-flipped-resistance">Flipped Resistance</label>
                    <select id="filter-flipped-resistance" class="filter-select">
                        <option value="all">All</option>
                        <option value="No Flipped Resistance">No Flipped Resistance</option>
                        <option value="Has Flipped Resistance">Has Flipped Resistance</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-liquidity-support">Liquidity Grab Support</label>
                    <select id="filter-liquidity-support" class="filter-select">
                        <option value="all">All</option>
                        <option value="Yes">Yes</option>
                        <option value="No">No</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-liquidity-resistance">Liquidity Grab Resistance</label>
                    <select id="filter-liquidity-resistance" class="filter-select">
                        <option value="all">All</option>
                        <option value="Yes">Yes</option>
                        <option value="No">No</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-cpr">Daily CPR</label>
                    <select id="filter-cpr" class="filter-select">
                        <option value="all">All</option>
                        <option value="Above CPR">Above CPR</option>
                        <option value="Below CPR">Below CPR</option>
                        <option value="Inside CPR">Inside CPR</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="filter-convergence">Support Convergence</label>
                    <select id="filter-convergence" class="filter-select">
                        <option value="all">All</option>
                        <option value="Solid Support">Solid Support</option>
                        <option value="No Convergence">No Convergence</option>
                    </select>
                </div>
                
                <!-- NEW RESISTANCE CONVERGENCE FILTER -->
                <div class="filter-group">
                    <label for="filter-resistance-convergence">Resistance Convergence</label>
                    <select id="filter-resistance-convergence" class="filter-select">
                        <option value="all">All</option>
                        <option value="Solid Resistance">Solid Resistance</option>
                        <option value="No Convergence">No Convergence</option>
                    </select>
                </div>
                
                <div class="filter-actions">
                    <button class="filter-btn primary" id="apply-filters">
                        <i class="fas fa-check"></i> Apply Filters
                    </button>
                    <button class="filter-btn" id="reset-filters">
                        <i class="fas fa-undo"></i> Reset All
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Active Filters Display -->
        <div class="active-filters" id="active-filters-container" style="display: none;">
            <div id="active-filters-list"></div>
            <button class="clear-filters-btn" id="clear-filters">
                <i class="fas fa-times"></i> Clear All Filters
            </button>
            <div class="filter-results" id="filter-results"></div>
        </div>
        
        <div class="error" id="error-message"></div>
        
        <div class="table-container">
            <table id="crypto-table">
                <thead>
                    <tr>
                        <th><i class="fas fa-coins"></i> Cryptocurrency Pair</th>
                        <th><i class="fas fa-dollar-sign"></i> Current Price</th>
                        <th><i class="fas fa-wave-square"></i> Swing Pattern</th>
                        <th><i class="fas fa-chart-bar"></i> MACD (1h)</th>
                        <th><i class="fas fa-exchange-alt"></i> MACD Crossover</th>
                        <th><i class="fas fa-chart-area"></i> Volume Spike</th>
                        <th><i class="fas fa-chart-line"></i> Volatility ATR (4h)</th>
                        <th><i class="fas fa-balance-scale"></i> OBV (1h)</th>
                        <th><i class="fas fa-cloud"></i> Ichimoku Cloud</th>
                        <th><i class="fas fa-chart-line"></i> EMA Position</th>
                        <th><i class="fas fa-link"></i> Correlation with BTC</th>
                        <th><i class="fas fa-shield-alt"></i> Support Levels (LL/HL)</th>
                        <th><i class="fas fa-exchange-alt"></i> Flipped Support (Breached HH/LH)</th>
                        <th><i class="fas fa-hand-point-down"></i> Liquidity Grab (Support)</th>
                        <th><i class="fas fa-ban"></i> Resistance Levels (HH/LH)</th>
                        <th><i class="fas fa-exchange-alt"></i> Flipped Resistance (Breached LL/HL)</th>
                        <th><i class="fas fa-hand-point-up"></i> Liquidity Grab (Resistance)</th>
                        <th><i class="fas fa-balance-scale"></i> Daily CPR (TC/CP/BC)</th>
                        <th><i class="fas fa-handshake"></i> Support Convergence</th>
                        <!-- NEW RESISTANCE CONVERGENCE COLUMN -->
                        <th><i class="fas fa-handshake"></i> Resistance Convergence</th>
                        <th><i class="fas fa-weight-hanging"></i> VWAP (Session)</th>
                        <th><i class="fas fa-clipboard-list"></i> Indicator Summary 1</th>
                        <th><i class="fas fa-clipboard-list"></i> Indicator Summary 2</th>
                        <th><i class="fas fa-clipboard-list"></i> Indicator Summary 3</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <tr class="loading">
                        <td colspan="24">
                            <div class="loading-spinner"></div>
                            <div>Loading cryptocurrency data from Binance...</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <!-- App Selection Modal -->
        <div class="app-modal" id="app-modal">
            <div class="app-modal-content">
                <h3><i class="fas fa-external-link-alt"></i> Open in TradingView</h3>
                <p>Would you like to open this chart in the TradingView mobile app or continue in browser?</p>
                <div class="app-modal-buttons">
                    <button class="app-modal-btn primary" id="open-app-btn">
                        <i class="fas fa-mobile-alt"></i> Open in App
                    </button>
                    <button class="app-modal-btn secondary" id="open-web-btn">
                        <i class="fas fa-globe"></i> Open in Browser
                    </button>
                    <button class="app-modal-btn secondary" id="cancel-btn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
        
        <div class="info-note">
            <p><strong>Note:</strong> Swing pattern analysis based on last 100 four-hour candlesticks in 1-hour mode, and 12-hour candlesticks in 4-hour mode. MACD analysis based on 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode (12,26,9 periods). Crossover detection looks for recent bullish or bearish crossovers. Volume spike detects if last closed 1-hour candle has 1.5x average volume of last 20 candles in 1-hour mode, and 4-hour candle in 4-hour mode. ATR (Average True Range) measures volatility based on 14-period calculation on 4-hour timeframe in 1-hour mode, and 12-hour timeframe in 4-hour mode. OBV (On Balance Volume) tracks cumulative volume flow on 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode. Ichimoku Cloud analysis based on standard settings (9,26,52) on 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode. EMA analysis based on selected period using 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode.</p>
            <p><strong>Correlation with BTC:</strong> Shows how closely the cryptocurrency's price movements correlate with Bitcoin over the last 24 hours. Lower correlation (green) indicates more independent movement from Bitcoin, while higher correlation (red) indicates the coin tends to follow Bitcoin's price action. Correlation is calculated using the Pearson correlation coefficient on 1-hour closing prices in both modes.</p>
            <p><strong>Support Levels (LL/HL):</strong> Identifies Lower Lows (LL) and Higher Lows (HL) that are below the current price and can act as support levels. Calculated using pivot detection with left/right bars of 20 on 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode.</p>
            <p><strong>Flipped Support (Breached HH/LH):</strong> Identifies Higher Highs (HH) and Lower Highs (LH) that have been breached (current price > pivot price) and can now act as support levels. These are former resistance levels that have flipped to support. Calculated on 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode.</p>
            <p><strong>Liquidity Grab (Support):</strong> Detects if a support level was breached (price closed below it) and then the price moved back up above that support level. This indicates a potential liquidity grab where the price "stops out" traders below support before reversing. Shows 'Yes' along with the specific support level value that was respected after the breach. Calculated on 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode.</p>
            <p><strong>Resistance Levels (HH/LH):</strong> Identifies Higher Highs (HH) and Lower Highs (LH) that are above the current price and can act as resistance levels. These are price levels where selling pressure may increase. Calculated on 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode.</p>
            <p><strong>Flipped Resistance (Breached LL/HL):</strong> Identifies Lower Lows (LL) and Higher Lows (HL) that have been breached (current price < pivot price) and can now act as resistance levels. These are former support levels that have flipped to resistance. Calculated on 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode.</p>
            <p><strong>Liquidity Grab (Resistance):</strong> Detects if a resistance level was breached (price closed above it) and then the price moved back down below that resistance level. This indicates a potential liquidity grab where the price "stops out" traders above resistance before reversing. Shows 'Yes' along with the specific resistance level value that was respected after the breach. Calculated on 1-hour timeframe in 1-hour mode, and 4-hour timeframe in 4-hour mode.</p>
            <p><strong>Daily CPR (Central Pivot Range):</strong> Calculates the daily Central Pivot Range based on PREVIOUS DAY'S high, low, and close using the EXACT formulas from TradingView's "Daily Pivots by GuruprasadMeduri" indicator. TC (Top Central), CP (Central Pivot), and BC (Bottom Central) are key levels for the current trading day. The indicator shows whether the current price is Above, Below, or Inside the CPR range. Same in both modes.</p>
            <p><strong>Support Convergence:</strong> Detects if any support or flipped support level is within 0.5% of any CPR level (TC, CP, or BC). When support levels converge with CPR levels, it indicates stronger potential support zones. "Solid Support" indicates convergence with the specific price point. Uses 1-hour supports in 1-hour mode, and 4-hour supports in 4-hour mode.</p>
            <p><strong>Resistance Convergence:</strong> Detects if any resistance or flipped resistance level is within 0.5% of any CPR level (TC, CP, or BC). When resistance levels converge with CPR levels, it indicates stronger potential resistance zones. "Solid Resistance" indicates convergence with the specific price point. Uses 1-hour resistances in 1-hour mode, and 4-hour resistances in 4-hour mode.</p>
            <p><strong>VWAP (Volume Weighted Average Price):</strong> Calculated using the session anchor period (daily) with source (H+L+C)/3 and standard deviation bands (1 std dev). VWAP is a benchmark that shows the average price weighted by volume throughout the trading session. The upper and lower bands represent 1 standard deviation from the VWAP line, showing where price is statistically overbought or oversold relative to volume-weighted average. Percentage distances show how far current price is from VWAP line and bands. Same in both modes.</p>
            <p><strong>Indicator Summary 1:</strong> MACD status, crossover signals, Ichimoku position, EMA relation, VWAP line and band distances.</p>
            <p><strong>Indicator Summary 2:</strong> Volume spikes, OBV trends, support distances, flipped support, liquidity grab support, resistance distances, flipped resistance, liquidity grab resistance.</p>
            <p><strong>Indicator Summary 3:</strong> CPR percentages, correlation with BTC, support convergence with CPR, resistance convergence with CPR, ATR volatility.</p>
            <p><strong>Color Coding:</strong> Green text indicates bullish/positive signals, red text indicates bearish/negative signals, yellow text indicates neutral signals.</p>
            <p><strong>Watchlist Feature:</strong> Click the star icon <i class="fas fa-star" style="color: #ffc107;"></i> next to any cryptocurrency to add it to your watchlist. Click the Watchlist tab to view only your selected coins. Your watchlist is saved in your browser's local storage.</p>
            <p><strong>TradingView Links:</strong> Click on any cryptocurrency name to open its 1-hour chart. On mobile, you'll be prompted to choose between opening in the TradingView app or browser. On desktop, it opens TradingView website in a new tab.</p>
            <p><strong>Mobile App Note:</strong> For the app to open directly, make sure you have the TradingView app installed and your browser is set to allow opening apps from links. On iOS, you may need to enable "Open in App" in Safari settings.</p>
            <p><strong>Filtering:</strong> Use the filter panel to find coins that match specific technical criteria. Apply filters to narrow down your search for trading opportunities.</p>
        </div>
        
        <footer>
            <p>Data provided by Binance Public API | Prices update every second via WebSocket | Swing analysis based on 4-hour candlesticks in 1-hour mode, 12-hour in 4-hour mode | Volatility (ATR) based on 4-hour timeframe in 1-hour mode, 12-hour in 4-hour mode | All other indicators based on selected timeframe mode | Correlation calculated over last 24 hours | CPR calculated from daily timeframe using PREVIOUS DAY'S data | VWAP calculated on daily session with (H+L+C)/3 source and 1 standard deviation bands</p>
            <p>This is a demonstration tool. Cryptocurrency investments are subject to market risk.</p>
        </footer>
    </div>

    <script>
        // Configuration
        const SYMBOLS = ['BTCUSDT', 'ETHUSDT', '0GUSDT', '1000CATUSDT', '1000CHEEMSUSDT', '1000SATSUSDT', '1INCHUSDT', '1MBABYDOGEUSDT', '2ZUSDT', 'A2ZUSDT', 'AAVEUSDT', 'ACAUSDT', 'ACCMUSDT', 'ACXUSDT', 'ACTUSDT', 'ADAUSDT', 'ADXUSDT', 'AEURUSDT', 'AEVOUSDT', 'AIGLDTUSDT', 'AIOUSDT', 'AIXBTUSDT', 'AGLDUSDT', 'ALCXUSDT', 'ALGOUSDT', 'ALICEUSDT', 'ALLOUSDT', 'ALPINEUSDT', 'ALTUSDT', 'AMPUSDT', 'ANIMEUSDT', 'ANKRUSDT', 'APEUSDT', 'API3USDT', 'APTUSDT', 'ARBUSDT', 'ARDRUSDT', 'AREUSDT', 'ARKMUSDT', 'ARKUSDT', 'ARPAUSDT', 'ARUSDT', 'ASRUSDT', 'ASTERUSDT', 'ATAUSDT', 'ATLASUSDT', 'ATMOSDT', 'ATOMUSDT', 'AUDIOUSDT', 'AUSDT', 'AVAUSDT', 'AVANTUSDT', 'AVAXUSDT', 'AXLUSDT', 'AXSUSDT', 'AZEURUSDT', 'BABYUSDT', 'BANANAUSDT', 'BANANAS31USDT', 'BANDUSDT', 'BARUSDT', 'BATUSDT', 'BBUSDT', 'BCHUSDT', 'BEAMXUSDT', 'BELUSDT', 'BERAUSDT', 'BFUSDUSDT', 'BICOUSDT', 'BIFIUSDT', 'BIGTIMEUSDT', 'BIOUSDT', 'BNTUSDT', 'BNBOSDT', 'BOMEUSDT', 'BONKUSDT', 'BROCCOLI714USDT', 'BTCUSDT', 'BTTUSDT', 'CAKEUSDT', 'CATIUSDT', 'CETUSUSDT', 'CFLXUSDT', 'CFXUSDT', 'CGBIOUSDT', 'CGPTUSDT', 'CELRUSDT', 'CELOUSDT', 'CHESSUSDT', 'CHZUSDT', 'CITYUSDT', 'CIVIOUSDT', 'CKBUSDT', 'CLARUSDT', 'CLUXUSDT', 'CLVRUSDT', 'COMPUSDT', 'COOKIEUSDT', 'COTIUSDT', 'COVLUSDT', 'COVUSDT', 'COWUSDT', 'CPOUSDT', 'CRVUSDT', 'CSPRUSDT', 'CTKUSDT', 'CTSIUSDT', 'CVCUSDT', 'CVXUSDT', 'CXCUSDT', 'CYBERUSDT', 'DASHUSDT', 'DATAUSDT', 'DEFIUSDT', 'DEGOUSDT', 'DENTUSDT', 'DFUSDT', 'DGBUSDT', 'DGLDUSDT', 'DIAUSDT', 'DNTUSDT', 'DOGEUSDT', 'DOGEOSDT', 'DOGOUSDT', 'DODOUSDT', 'DOLUSDT', 'DOLXUSDT', 'DREAMUSDT', 'DUSDT', 'DUSUSDT', 'DYDXUSDT', 'DYMUSDT', 'EDENUSDT', 'EDUSDT', 'EGLDUSDT', 'EIGENUSDT', 'ENJUSDT', 'ENSOUSDT', 'ENSUSDT', 'EPICTUSDT', 'EPOUSDT', 'ERAUSDT', 'ETCUSDT', 'ETHFIUSDT', 'EURUSDT', 'EURIUSDT', 'EULUSDT', 'FARMUSDT', 'FETUSDT', 'FFUSDT', 'FIDAUSDT', 'FILUSDT', 'FIOUSDT', 'FISUSDT', 'FLMUSDT', 'FLOKIUSDT', 'FLOWUSDT', 'FORTHUSDT', 'FTMUSDT', 'FTTUSDT', 'FUNUSDT', 'GALUSDT', 'GALAUSDT', 'GASUSDT', 'GGMUSDT', 'GFUSDT', 'GHSTUSDT', 'GIGGLEUSDT', 'GLMRUSDT', 'GLMUSDT', 'GMTUSDT', 'GMMUSDT', 'GMXUSDT', 'GNOUSDT', 'GNOSUSDT', 'GNSUSDT', 'GODUSDT', 'GRATUSDT', 'GRTUSDT', 'GTCUSDT', 'GUNUSDT', 'HADOUSDT', 'HEDALUSDT', 'HEMIUSDT', 'HFTUSDT', 'HIGHUSDT', 'HIVEUSDT', 'HMSTRUSDT', 'HOLOUSDT', 'HOMEUSDT', 'HOTUSDT', 'HUMAUSDT', 'HYPERUSDT', 'ICOUSDT', 'ICPUSDT', 'ICXUSDT', 'IDEXUSDT', 'IDUSDT', 'ILVUSDT', 'IMXUSDT', 'INJUSDT', 'INITUSDT', 'IOTAUSDT', 'IOTXUSDT', 'IOUSDT', 'IQUSDT', 'JASMYUSDT', 'JSTUSDT', 'JTOUSDT', 'JUPUSDT', 'KAIAUSDT', 'KAIUSDT', 'KAVAUSDT', 'KERNALUSDT', 'KITESUSDT', 'KLAYUSDT', 'KMNOUSDT', 'KNCUSDT', 'KSMUSDT', 'LAYERUSDT', 'LAUSDT', 'LDOUSDT', 'LINKUSDT', 'LISTAUSDT', 'LITUSDT', 'LIVIOUSDT', 'LPCUSDT', 'LPTUSDT', 'LQTYUSDT', 'LRCUSDT', 'LSKUSDT', 'LTCUSDT', 'MAGICUSDT', 'MANAUSDT', 'MANTAUSDT', 'MASKUSDT', 'MATICUSDT', 'MBLUSDT', 'MBOXUSDT', 'MDTUSDT', 'MELOSUSDT', 'METAUSDT', 'METISUSDT', 'MEEUSDT', 'MEUSDT', 'MFTUSDT', 'MINAUSDT', 'MIRRAUSDT', 'MITOUSDT', 'MKRUSDT', 'MLNUSDT', 'MMSUSDT', 'MMTUSDT', 'MOVEUSDT', 'MOVRUSDT', 'MPLUSDT', 'MROUSDT', 'MTLUSDT', 'MUBARAKUSDT', 'MYROUSDT', 'NANOUSDT', 'NEARUSDT', 'NEIROUSDT', 'NEOUSDT', 'NEXOUSDT', 'NFPUSDT', 'NILUSDT', 'NKNUSDT', 'NMRUSDT', 'NOMUSDT', 'NXPCUSDT', 'OAXUSDT', 'OGNUSDT', 'OGUSDT', 'OMUSDT', 'ONDOUSDT', 'ONEUSDT', 'ONGUSDT', 'ONTUSDT', 'ONYXUSDT', 'OPENUSDT', 'OPUSDT', 'ORBSUSDT', 'ORCAUSDT', 'ORDIUSDT', 'OSMOUSDT', 'OXTUSDT', 'PAXGUSDT', 'PEOPLEUSDT', 'PEPEUSDT', 'PENDLEUSDT', 'PHAUSDT', 'PHABUSDT', 'PHBUSDT', 'PIXELUSDT', 'PIVXUSDT', 'PLUMEUSDT', 'POLUSDT', 'POLYXUSDT', 'PONDUSDT', 'PORTALUSDT', 'PORTOUSDT', 'POWRUSDT', 'PROMUSDT', 'PROVEUSDT', 'PSGUSDT', 'PTRUSDT', 'PYRUSDT', 'PYTHUSDT', 'QKCUSDT', 'QNTUSDT', 'QTUMUSDT', 'QUICKUSDT', 'RACEUSDT', 'RADUSDT', 'RAYUSDT', 'RDNTUSDT', 'REBUSDT', 'REIUSDT', 'RENUSDT', 'RENDUSDT', 'REQUSDT', 'REZUSDT', 'RIFUSDT', 'RLCUSDT', 'RNDRUSDT', 'RONINUSDT', 'ROSEUSDT', 'RPLUSDT', 'RSRUSDT', 'RUNEUSDT', 'RVNUSDT', 'SAGAUSDT', 'SANDUSDT', 'SANTOSUSDT', 'SAPIEUSDT', 'SCRTUSDT', 'SCRUSDT', 'SCUSDT', 'SEIUSDT', 'SFPUSDT', 'SHELLUSDT', 'SHIBUSDT', 'SKLUSDT', 'SLPUSDT', 'SOLUSDT', 'SOLVUSDT', 'SOMIUSDT', 'SPELLUSDT', 'SPKUSDT', 'STAXUSDT', 'STGUSDT', 'STORJUSDT', 'STOUSDT', 'STRAXUSDT', 'STRKUSDT', 'STXUSDT', 'SUNUSDT', 'SUIUSDT', 'SUPERUSDT', 'SUSHIUSDT', 'SUSDT', 'SXPUSDT', 'SYRUPUSDT', 'SYSUSDT', 'TAOUSDT', 'TETRAUSDT', 'TFUELUSDT', 'THETAUSDT', 'THTUSDT', 'TIAUSDT', 'TKOUSDT', 'TLMUSDT', 'TOMUSDT', 'TOWNUSDT', 'TRBUSDT', 'TRUMPUSDT', 'TRXUSDT', 'TURBOUSDT', 'TUTUSDT', 'TWTUSDT', 'TZIOUSDT', 'UFTUSDT', 'UMAUSDT', 'UNIUSDT', 'USDCUSDT', 'USDEUSDT', 'USDPUSDT', 'USD1USDT', 'USTCUSDT', 'UTKUSDT', 'VANAUSDT', 'VCTUSDT', 'VELODROMEUSDT', 'VETUSDT', 'VICUSDT', 'VIRTUALUSDT', 'VOXELUSDT', 'WALUSDT', 'WANUSDT', 'WAVESUSDT', 'WAXPUSDT', 'WBETHUSDT', 'WBTCUSDT', 'WCTUSDT', 'WIFUSDT', 'WLDUSDT', 'WINUSDT', 'WOOUSDT', 'WRXUSDT', 'WUSDT', 'XAIUSDT', 'XECUSDT', 'XENOUSDT', 'XLMUSDT', 'XMRUSDT', 'XNOUSDT', 'XPCUSDT', 'XPLUSDT', 'XRPUSDT', 'XTZUSDT', 'XUSDUSDT', 'XVSUSDT', 'YBUSDT', 'YFIUSDT', 'YGGUSDT', 'ZECUSDT', 'ZENUSDT', 'ZILUSDT', 'ZKCUSDT', 'ZROUSDT', 'ZRXUSDT', 'ZTBUSDT', 'ZUSDT'];
        const HISTORICAL_UPDATE_INTERVAL = 60000; // Update historical data every minute
        const CANDLE_LIMIT = 100;
        const MACD_CANDLE_LIMIT = 200;
        const VOLUME_CANDLE_LIMIT = 22;
        const ATR_PERIOD = 14;
        const OBV_PERIOD = 20;
        const CORRELATION_PERIOD = 24;
        const SUPPORT_LEVELS_LIMIT = 200;
        const LEFT_BARS = 20;
        const RIGHT_BARS = 20;
        const LIQUIDITY_GRAB_LOOKBACK = 30; // Look back 30 candles for liquidity grab detection
        
        // State variables
        let cryptoData = {};
        let lastPrices = {};
        let historicalUpdateTimer = null;
        let isUpdating = false;
        let currentEMAPeriod = 20;
        let watchlist = new Set();
        let currentView = 'all';
        let currentSymbolForLink = null;
        let btcHourlyPrices = [];
        let wsConnections = {};
        let lastUpdateTimes = {};
        const WS_UPDATE_THROTTLE = 1000; // Throttle WebSocket updates to 1 second
        let currentTimeframe = '1h'; // '1h' or '4h'
        
        // Filter state
        let activeFilters = {
            macd: 'all',
            crossover: 'all',
            volume: 'all',
            atr: 'all',
            obv: 'all',
            ichimoku: 'all',
            ema: 'all',
            correlation: 'all',
            support: 'all',
            flippedSupport: 'all',
            resistance: 'all',
            flippedResistance: 'all',
            liquiditySupport: 'all',
            liquidityResistance: 'all',
            cpr: 'all',
            convergence: 'all',
            resistanceConvergence: 'all' // NEW: Resistance Convergence filter
        };
        
        // DOM elements
        const tableBody = document.getElementById('table-body');
        const lastUpdatedTime = document.getElementById('last-updated-time');
        const errorMessage = document.getElementById('error-message');
        const refreshButton = document.getElementById('refresh-data');
        const viewAllBtn = document.getElementById('view-all-btn');
        const viewWatchlistBtn = document.getElementById('view-watchlist-btn');
        const emaPeriodSelect = document.getElementById('ema-period');
        const timeframeSelect = document.getElementById('timeframe-select');
        const currentTimeframeSpan = document.querySelector('.current-timeframe');
        const watchlistCount = document.getElementById('watchlist-count');
        const watchlistBadge = document.getElementById('watchlist-badge');
        const watchlistCountDisplay = document.getElementById('watchlist-count-display');
        const appModal = document.getElementById('app-modal');
        const openAppBtn = document.getElementById('open-app-btn');
        const openWebBtn = document.getElementById('open-web-btn');
        const cancelBtn = document.getElementById('cancel-btn');
        
        // Filter DOM elements
        const filterPanelToggle = document.getElementById('filter-panel-toggle');
        const filterPanel = document.getElementById('filter-panel');
        const filterPanelIcon = document.getElementById('filter-panel-icon');
        const applyFiltersBtn = document.getElementById('apply-filters');
        const resetFiltersBtn = document.getElementById('reset-filters');
        const clearFiltersBtn = document.getElementById('clear-filters');
        const activeFiltersContainer = document.getElementById('active-filters-container');
        const activeFiltersList = document.getElementById('active-filters-list');
        const filterResults = document.getElementById('filter-results');
        
        // Filter select elements
        const filterMacd = document.getElementById('filter-macd');
        const filterCrossover = document.getElementById('filter-crossover');
        const filterVolume = document.getElementById('filter-volume');
        const filterAtr = document.getElementById('filter-atr');
        const filterObv = document.getElementById('filter-obv');
        const filterIchimoku = document.getElementById('filter-ichimoku');
        const filterEma = document.getElementById('filter-ema');
        const filterCorrelation = document.getElementById('filter-correlation');
        const filterSupport = document.getElementById('filter-support');
        const filterFlippedSupport = document.getElementById('filter-flipped-support');
        const filterResistance = document.getElementById('filter-resistance');
        const filterFlippedResistance = document.getElementById('filter-flipped-resistance');
        const filterLiquiditySupport = document.getElementById('filter-liquidity-support');
        const filterLiquidityResistance = document.getElementById('filter-liquidity-resistance');
        const filterCpr = document.getElementById('filter-cpr');
        const filterConvergence = document.getElementById('filter-convergence');
        const filterResistanceConvergence = document.getElementById('filter-resistance-convergence'); // NEW
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadWatchlist();
            
            // Initialize filter panel
            filterPanelToggle.addEventListener('click', toggleFilterPanel);
            applyFiltersBtn.addEventListener('click', applyFilters);
            resetFiltersBtn.addEventListener('click', resetFilters);
            clearFiltersBtn.addEventListener('click', clearFilters);
            
            // Add change listeners to filter selects
            const filterSelects = document.querySelectorAll('.filter-select');
            filterSelects.forEach(select => {
                select.addEventListener('change', function() {
                    // Update active filters object
                    const filterId = this.id.replace('filter-', '');
                    activeFilters[filterId] = this.value;
                    
                    // Apply filters immediately when changed
                    applyFilters();
                });
            });
            
            viewAllBtn.addEventListener('click', function() {
                setActiveView('all');
                updateTable();
                applyFilters(); // Re-apply filters after view change
            });
            
            viewWatchlistBtn.addEventListener('click', function() {
                setActiveView('watchlist');
                updateTable();
                applyFilters(); // Re-apply filters after view change
            });
            
            emaPeriodSelect.addEventListener('change', function() {
                currentEMAPeriod = parseInt(this.value);
                Object.keys(cryptoData).forEach(symbol => {
                    if (cryptoData[symbol].indicatorKlines) {
                        const emaAnalysis = calculateEMAAnalysis(cryptoData[symbol].indicatorKlines, cryptoData[symbol].currentPrice, currentEMAPeriod);
                        cryptoData[symbol].emaAnalysis = emaAnalysis;
                        cryptoData[symbol].indicatorSummary = calculateIndicatorSummary(cryptoData[symbol], cryptoData[symbol].currentPrice);
                    }
                });
                updateTable();
                applyFilters(); // Re-apply filters after EMA period change
            });
            
            timeframeSelect.addEventListener('change', function() {
                currentTimeframe = this.value;
                updateTimeframeDisplay();
                clearInterval(historicalUpdateTimer);
                fetchAllHistoricalData();
                historicalUpdateTimer = setInterval(fetchAllHistoricalData, HISTORICAL_UPDATE_INTERVAL);
            });
            
            openAppBtn.addEventListener('click', function() {
                if (currentSymbolForLink) {
                    openTradingViewApp(currentSymbolForLink);
                    hideAppModal();
                }
            });
            
            openWebBtn.addEventListener('click', function() {
                if (currentSymbolForLink) {
                    openTradingViewWeb(currentSymbolForLink);
                    hideAppModal();
                }
            });
            
            cancelBtn.addEventListener('click', function() {
                hideAppModal();
            });
            
            appModal.addEventListener('click', function(e) {
                if (e.target === appModal) {
                    hideAppModal();
                }
            });
            
            tableBody.addEventListener('click', function(event) {
                if (event.target.closest('.watchlist-star') || event.target.classList.contains('watchlist-star')) {
                    const starElement = event.target.closest('.watchlist-star') || event.target;
                    const symbol = starElement.getAttribute('data-symbol');
                    if (symbol) {
                        toggleWatchlist(symbol);
                    }
                    event.preventDefault();
                    event.stopPropagation();
                }
                
                if (event.target.closest('.crypto-link') || event.target.classList.contains('crypto-link')) {
                    const linkElement = event.target.closest('.crypto-link') || event.target;
                    const symbolMatch = linkElement.id ? linkElement.id.match(/link-(.+)/) : null;
                    if (symbolMatch && symbolMatch[1]) {
                        const symbol = symbolMatch[1];
                        handleTradingViewClick(symbol, event);
                    }
                    event.preventDefault();
                    event.stopPropagation();
                }
            });
            
            fetchAllHistoricalData();
            
            historicalUpdateTimer = setInterval(fetchAllHistoricalData, HISTORICAL_UPDATE_INTERVAL);
            
            refreshButton.addEventListener('click', function() {
                clearInterval(historicalUpdateTimer);
                fetchAllHistoricalData();
                historicalUpdateTimer = setInterval(fetchAllHistoricalData, HISTORICAL_UPDATE_INTERVAL);
            });
            
            setInterval(updateTimeDisplay, 1000);
            
            updateWatchlistCount();
        });
        
        // Toggle filter panel visibility
        function toggleFilterPanel() {
            filterPanel.classList.toggle('collapsed');
            filterPanelIcon.classList.toggle('rotated');
        }
        
        // Apply filters to the table
        function applyFilters() {
            // Get all filter values
            activeFilters = {
                macd: filterMacd.value,
                crossover: filterCrossover.value,
                volume: filterVolume.value,
                atr: filterAtr.value,
                obv: filterObv.value,
                ichimoku: filterIchimoku.value,
                ema: filterEma.value,
                correlation: filterCorrelation.value,
                support: filterSupport.value,
                flippedSupport: filterFlippedSupport.value,
                resistance: filterResistance.value,
                flippedResistance: filterFlippedResistance.value,
                liquiditySupport: filterLiquiditySupport.value,
                liquidityResistance: filterLiquidityResistance.value,
                cpr: filterCpr.value,
                convergence: filterConvergence.value,
                resistanceConvergence: filterResistanceConvergence.value // NEW
            };
            
            // Update active filters display
            updateActiveFiltersDisplay();
            
            // Get all table rows with data
            const rows = tableBody.querySelectorAll('tr[data-symbol]');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const symbol = row.getAttribute('data-symbol');
                const data = cryptoData[symbol];
                
                if (!data) {
                    row.style.display = 'none';
                    return;
                }
                
                // Check if row passes all filters
                let passesFilters = true;
                
                // MACD filter
                if (activeFilters.macd !== 'all') {
                    const macdStatus = data.macdAnalysis?.status || 'neutral';
                    const macdText = macdStatus.charAt(0).toUpperCase() + macdStatus.slice(1);
                    if (macdText !== activeFilters.macd) {
                        passesFilters = false;
                    }
                }
                
                // MACD Crossover filter
                if (passesFilters && activeFilters.crossover !== 'all') {
                    const crossoverType = data.macdAnalysis?.crossover || 'none';
                    let crossoverText = 'None';
                    if (crossoverType === 'bullish') crossoverText = 'Bullish Crossover';
                    else if (crossoverType === 'bearish') crossoverText = 'Bearish Crossover';
                    
                    if (crossoverText !== activeFilters.crossover) {
                        passesFilters = false;
                    }
                }
                
                // Volume Spike filter
                if (passesFilters && activeFilters.volume !== 'all') {
                    const hasVolumeSpike = data.volumeSpike?.spike || false;
                    const volumeText = hasVolumeSpike ? 'Spike' : 'Normal';
                    if (volumeText !== activeFilters.volume) {
                        passesFilters = false;
                    }
                }
                
                // ATR Volatility filter
                if (passesFilters && activeFilters.atr !== 'all') {
                    const atrVolatility = data.atrAnalysis?.volatility || 'low';
                    const atrText = atrVolatility.charAt(0).toUpperCase() + atrVolatility.slice(1);
                    if (atrText !== activeFilters.atr) {
                        passesFilters = false;
                    }
                }
                
                // OBV filter
                if (passesFilters && activeFilters.obv !== 'all') {
                    const obvTrend = data.obvAnalysis?.trend || 'neutral';
                    let obvText = 'None';
                    if (obvTrend === 'rising') obvText = 'Rising Volume';
                    else if (obvTrend === 'falling') obvText = 'Declining Volume';
                    
                    if (obvText !== activeFilters.obv) {
                        passesFilters = false;
                    }
                }
                
                // Ichimoku Cloud filter
                if (passesFilters && activeFilters.ichimoku !== 'all') {
                    const ichimokuPosition = data.ichimokuAnalysis?.cloudPosition || 'inside';
                    const ichimokuText = ichimokuPosition.charAt(0).toUpperCase() + ichimokuPosition.slice(1) + ' Cloud';
                    if (ichimokuText !== activeFilters.ichimoku) {
                        passesFilters = false;
                    }
                }
                
                // EMA filter
                if (passesFilters && activeFilters.ema !== 'all') {
                    const emaPosition = data.emaAnalysis?.position || 'cross';
                    let emaText = 'Near EMA';
                    if (emaPosition === 'above') emaText = 'Above EMA';
                    else if (emaPosition === 'below') emaText = 'Below EMA';
                    
                    if (emaText !== activeFilters.ema) {
                        passesFilters = false;
                    }
                }
                
                // Correlation filter
                if (passesFilters && activeFilters.correlation !== 'all') {
                    const correlationStrength = data.correlationWithBTC?.strength || 'unknown';
                    const correlationText = correlationStrength.charAt(0).toUpperCase() + correlationStrength.slice(1);
                    if (correlationText !== activeFilters.correlation) {
                        passesFilters = false;
                    }
                }
                
                // Support Level filter
                if (passesFilters && activeFilters.support !== 'all') {
                    const hasSupport = (data.supportLevels && data.supportLevels.length > 0) || false;
                    const supportText = hasSupport ? 'Has Support' : 'No Support';
                    if (supportText !== activeFilters.support) {
                        passesFilters = false;
                    }
                }
                
                // Flipped Support filter
                if (passesFilters && activeFilters.flippedSupport !== 'all') {
                    const hasFlippedSupport = (data.flippedLevels && data.flippedLevels.length > 0) || false;
                    const flippedSupportText = hasFlippedSupport ? 'Has Flipped Support' : 'No Flipped Support';
                    if (flippedSupportText !== activeFilters.flippedSupport) {
                        passesFilters = false;
                    }
                }
                
                // Resistance Level filter
                if (passesFilters && activeFilters.resistance !== 'all') {
                    const hasResistance = (data.resistanceLevels && data.resistanceLevels.length > 0) || false;
                    const resistanceText = hasResistance ? 'Has Resistance' : 'No Resistance';
                    if (resistanceText !== activeFilters.resistance) {
                        passesFilters = false;
                    }
                }
                
                // Flipped Resistance filter
                if (passesFilters && activeFilters.flippedResistance !== 'all') {
                    const hasFlippedResistance = (data.flippedResistanceLevels && data.flippedResistanceLevels.length > 0) || false;
                    const flippedResistanceText = hasFlippedResistance ? 'Has Flipped Resistance' : 'No Flipped Resistance';
                    if (flippedResistanceText !== activeFilters.flippedResistance) {
                        passesFilters = false;
                    }
                }
                
                // Liquidity Grab Support filter
                if (passesFilters && activeFilters.liquiditySupport !== 'all') {
                    const hasLiquiditySupport = data.liquidityGrabSupport?.detected || false;
                    const liquiditySupportText = hasLiquiditySupport ? 'Yes' : 'No';
                    if (liquiditySupportText !== activeFilters.liquiditySupport) {
                        passesFilters = false;
                    }
                }
                
                // Liquidity Grab Resistance filter
                if (passesFilters && activeFilters.liquidityResistance !== 'all') {
                    const hasLiquidityResistance = data.liquidityGrabResistance?.detected || false;
                    const liquidityResistanceText = hasLiquidityResistance ? 'Yes' : 'No';
                    if (liquidityResistanceText !== activeFilters.liquidityResistance) {
                        passesFilters = false;
                    }
                }
                
                // CPR filter
                if (passesFilters && activeFilters.cpr !== 'all') {
                    const cprPosition = data.cprAnalysis?.position || 'inside';
                    let cprText = 'Inside CPR';
                    if (cprPosition === 'above') cprText = 'Above CPR';
                    else if (cprPosition === 'below') cprText = 'Below CPR';
                    
                    if (cprText !== activeFilters.cpr) {
                        passesFilters = false;
                    }
                }
                
                // Support Convergence filter
                if (passesFilters && activeFilters.convergence !== 'all') {
                    const hasConvergence = data.supportConvergence?.status === 'Solid Support' || false;
                    const convergenceText = hasConvergence ? 'Solid Support' : 'No Convergence';
                    if (convergenceText !== activeFilters.convergence) {
                        passesFilters = false;
                    }
                }
                
                // NEW: Resistance Convergence filter
                if (passesFilters && activeFilters.resistanceConvergence !== 'all') {
                    const hasResistanceConvergence = data.resistanceConvergence?.status === 'Solid Resistance' || false;
                    const resistanceConvergenceText = hasResistanceConvergence ? 'Solid Resistance' : 'No Convergence';
                    if (resistanceConvergenceText !== activeFilters.resistanceConvergence) {
                        passesFilters = false;
                    }
                }
                
                // Show or hide the row based on filter results
                if (passesFilters) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update filter results display
            updateFilterResults(visibleCount, rows.length);
            
            // Show/hide active filters container
            const hasActiveFilters = Object.values(activeFilters).some(filter => filter !== 'all');
            activeFiltersContainer.style.display = hasActiveFilters ? 'flex' : 'none';
        }
        
        // Update active filters display
        function updateActiveFiltersDisplay() {
            activeFiltersList.innerHTML = '';
            
            Object.keys(activeFilters).forEach(filterKey => {
                if (activeFilters[filterKey] !== 'all') {
                    const filterName = filterKey.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    const filterValue = activeFilters[filterKey];
                    
                    const filterTag = document.createElement('div');
                    filterTag.className = 'active-filter-tag';
                    filterTag.innerHTML = `
                        ${filterName}: ${filterValue}
                        <i class="fas fa-times" data-filter="${filterKey}"></i>
                    `;
                    
                    // Add click event to remove individual filter
                    const removeBtn = filterTag.querySelector('i');
                    removeBtn.addEventListener('click', function() {
                        const filterToRemove = this.getAttribute('data-filter');
                        resetSingleFilter(filterToRemove);
                    });
                    
                    activeFiltersList.appendChild(filterTag);
                }
            });
        }
        
        // Reset a single filter
        function resetSingleFilter(filterKey) {
            const filterElement = document.getElementById(`filter-${filterKey}`);
            if (filterElement) {
                filterElement.value = 'all';
                activeFilters[filterKey] = 'all';
                applyFilters();
            }
        }
        
        // Reset all filters
        function resetFilters() {
            const filterSelects = document.querySelectorAll('.filter-select');
            filterSelects.forEach(select => {
                select.value = 'all';
            });
            
            // Reset active filters object
            Object.keys(activeFilters).forEach(key => {
                activeFilters[key] = 'all';
            });
            
            applyFilters();
        }
        
        // Clear all filters (same as reset)
        function clearFilters() {
            resetFilters();
        }
        
        // Update filter results display
        function updateFilterResults(visible, total) {
            if (visible === total) {
                filterResults.textContent = `Showing all ${total} coins`;
            } else {
                filterResults.textContent = `Showing ${visible} of ${total} coins`;
            }
        }
        
        // Update timeframe display
        function updateTimeframeDisplay() {
            const timeframeText = currentTimeframe === '1h' ? '1 Hour Timeframe' : '4 Hour Timeframe';
            currentTimeframeSpan.textContent = `(${timeframeText})`;
            
            // Update table headers based on timeframe
            updateTableHeaders();
        }
        
        // Update table headers based on timeframe
        function updateTableHeaders() {
            const headers = document.querySelectorAll('th');
            if (headers.length >= 24) {
                // Update MACD header
                if (currentTimeframe === '1h') {
                    headers[3].innerHTML = '<i class="fas fa-chart-bar"></i> MACD (1h)';
                    headers[5].innerHTML = '<i class="fas fa-chart-line"></i> Volatility ATR (4h)';
                    headers[7].innerHTML = '<i class="fas fa-balance-scale"></i> OBV (1h)';
                } else {
                    headers[3].innerHTML = '<i class="fas fa-chart-bar"></i> MACD (4h)';
                    headers[5].innerHTML = '<i class="fas fa-chart-line"></i> Volatility ATR (12h)';
                    headers[7].innerHTML = '<i class="fas fa-balance-scale"></i> OBV (4h)';
                }
            }
        }
        
        // Pivot detection functions
        function pivotHigh(highs, index, left, right) {
            if (index < left || index >= highs.length - right) return false;
            
            const currentHigh = highs[index];
            for (let i = index - left; i <= index + right; i++) {
                if (i === index) continue;
                if (highs[i] >= currentHigh) return false;
            }
            return true;
        }
        
        function pivotLow(lows, index, left, right) {
            if (index < left || index >= lows.length - right) return false;
            
            const currentLow = lows[index];
            for (let i = index - left; i <= index + right; i++) {
                if (i === index) continue;
                if (lows[i] <= currentLow) return false;
            }
            return true;
        }
        
        // Calculate market structure (Support Levels, Flipped Support, Resistance Levels, Flipped Resistance)
        function calculateMarketStructure(klines, currentPrice) {
            if (!klines || klines.length < 50) {
                return { 
                    supportLevels: [], 
                    flippedLevels: [],
                    resistanceLevels: [],
                    flippedResistanceLevels: [] 
                };
            }
            
            const highs = klines.map(c => parseFloat(c.high));
            const lows = klines.map(c => parseFloat(c.low));
            
            const ph = new Array(klines.length).fill(false);
            const pl = new Array(klines.length).fill(false);
            const hl = new Array(klines.length).fill(null);
            const zz = new Array(klines.length).fill(null);
            
            for (let i = LEFT_BARS; i < klines.length - RIGHT_BARS; i++) {
                ph[i] = pivotHigh(highs, i, LEFT_BARS, RIGHT_BARS);
                pl[i] = pivotLow(lows, i, LEFT_BARS, RIGHT_BARS);
                
                if (ph[i]) {
                    hl[i] = 1;
                    zz[i] = highs[i];
                } else if (pl[i]) {
                    hl[i] = -1;
                    zz[i] = lows[i];
                }
            }
            
            const filteredZZ = [...zz];
            const filteredHL = [...hl];
            
            const supports = [];
            const flippedSupports = [];
            const resistances = [];
            const flippedResistances = [];
            
            for (let i = 0; i < klines.length; i++) {
                if (filteredZZ[i] !== null && filteredHL[i] === -1) {
                    if (currentPrice > filteredZZ[i]) {
                        supports.push({
                            price: filteredZZ[i],
                            index: i,
                            type: 'LL/HL'
                        });
                    } else {
                        // This is a pivot low above current price - potential resistance
                        flippedResistances.push({
                            price: filteredZZ[i],
                            index: i,
                            type: 'LL/HL',
                            breached: true
                        });
                    }
                } else if (filteredZZ[i] !== null && filteredHL[i] === 1) {
                    if (currentPrice < filteredZZ[i]) {
                        resistances.push({
                            price: filteredZZ[i],
                            index: i,
                            type: 'HH/LH'
                        });
                    } else {
                        // This is a pivot high below current price - potential support
                        flippedSupports.push({
                            price: filteredZZ[i],
                            index: i,
                            type: 'HH/LH',
                            breached: true
                        });
                    }
                }
            }
            
            supports.sort((a, b) => b.price - a.price);
            flippedSupports.sort((a, b) => b.price - a.price);
            resistances.sort((a, b) => a.price - b.price);
            flippedResistances.sort((a, b) => a.price - b.price);
            
            const uniqueSupports = [];
            const uniqueFlipped = [];
            const uniqueResistances = [];
            const uniqueFlippedResistances = [];
            
            supports.forEach(s => {
                if (!uniqueSupports.find(us => Math.abs(us.price - s.price) / s.price < 0.005)) {
                    uniqueSupports.push(s);
                }
            });
            
            flippedSupports.forEach(f => {
                if (!uniqueFlipped.find(uf => Math.abs(uf.price - f.price) / f.price < 0.005)) {
                    uniqueFlipped.push(f);
                }
            });
            
            resistances.forEach(r => {
                if (!uniqueResistances.find(ur => Math.abs(ur.price - r.price) / r.price < 0.005)) {
                    uniqueResistances.push(r);
                }
            });
            
            flippedResistances.forEach(fr => {
                if (!uniqueFlippedResistances.find(ufr => Math.abs(ufr.price - fr.price) / fr.price < 0.005)) {
                    uniqueFlippedResistances.push(fr);
                }
            });
            
            const closestSupports = uniqueSupports
                .map(s => ({
                    ...s,
                    distance: Math.abs(s.price - currentPrice)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);
            
            const closestFlipped = uniqueFlipped
                .map(f => ({
                    ...f,
                    distance: Math.abs(f.price - currentPrice)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);
            
            const closestResistances = uniqueResistances
                .map(r => ({
                    ...r,
                    distance: Math.abs(r.price - currentPrice)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);
            
            const closestFlippedResistances = uniqueFlippedResistances
                .map(fr => ({
                    ...fr,
                    distance: Math.abs(fr.price - currentPrice)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);
            
            return {
                supportLevels: closestSupports,
                flippedLevels: closestFlipped,
                resistanceLevels: closestResistances,
                flippedResistanceLevels: closestFlippedResistances
            };
        }
        
        // Calculate Liquidity Grab (Support)
        function calculateLiquidityGrabSupport(supportLevels, klines, currentPrice) {
            if (!supportLevels || supportLevels.length === 0 || !klines || klines.length < LIQUIDITY_GRAB_LOOKBACK) {
                return {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Insufficient data'
                };
            }
            
            // Get the last LIQUIDITY_GRAB_LOOKBACK candles for analysis
            const recentCandles = klines.slice(-LIQUIDITY_GRAB_LOOKBACK);
            
            let detectedGrab = null;
            let grabLevel = null;
            
            // Check each support level for liquidity grab pattern
            for (const support of supportLevels) {
                let breached = false;
                let reclaimed = false;
                let breachIndex = -1;
                let reclaimIndex = -1;
                
                // Check recent candles for breach and reclaim pattern
                for (let i = 0; i < recentCandles.length; i++) {
                    const candle = recentCandles[i];
                    
                    // Check if candle closed below support level (breach)
                    if (!breached && candle.close < support.price) {
                        breached = true;
                        breachIndex = i;
                    }
                    
                    // Check if after breach, candle closed above support level (reclaim)
                    if (breached && !reclaimed && candle.close > support.price && i > breachIndex) {
                        reclaimed = true;
                        reclaimIndex = i;
                    }
                }
                
                // If both breach and reclaim happened, we have a liquidity grab
                if (breached && reclaimed) {
                    // Check if current price is still above the support level (respected after reclaim)
                    if (currentPrice > support.price) {
                        detectedGrab = support;
                        break;
                    }
                }
            }
            
            if (detectedGrab) {
                return {
                    detected: true,
                    level: detectedGrab,
                    price: detectedGrab.price,
                    details: `Support at $${formatNumber(detectedGrab.price)} was breached and then reclaimed`
                };
            } else {
                return {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'No liquidity grab detected for support levels'
                };
            }
        }
        
        // Calculate Liquidity Grab (Resistance)
        function calculateLiquidityGrabResistance(resistanceLevels, klines, currentPrice) {
            if (!resistanceLevels || resistanceLevels.length === 0 || !klines || klines.length < LIQUIDITY_GRAB_LOOKBACK) {
                return {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Insufficient data'
                };
            }
            
            // Get the last LIQUIDITY_GRAB_LOOKBACK candles for analysis
            const recentCandles = klines.slice(-LIQUIDITY_GRAB_LOOKBACK);
            
            let detectedGrab = null;
            let grabLevel = null;
            
            // Check each resistance level for liquidity grab pattern
            for (const resistance of resistanceLevels) {
                let breached = false;
                let reclaimed = false;
                let breachIndex = -1;
                let reclaimIndex = -1;
                
                // Check recent candles for breach and reclaim pattern
                for (let i = 0; i < recentCandles.length; i++) {
                    const candle = recentCandles[i];
                    
                    // Check if candle closed above resistance level (breach)
                    if (!breached && candle.close > resistance.price) {
                        breached = true;
                        breachIndex = i;
                    }
                    
                    // Check if after breach, candle closed below resistance level (reclaim)
                    if (breached && !reclaimed && candle.close < resistance.price && i > breachIndex) {
                        reclaimed = true;
                        reclaimIndex = i;
                    }
                }
                
                // If both breach and reclaim happened, we have a liquidity grab
                if (breached && reclaimed) {
                    // Check if current price is still below the resistance level (respected after reclaim)
                    if (currentPrice < resistance.price) {
                        detectedGrab = resistance;
                        break;
                    }
                }
            }
            
            if (detectedGrab) {
                return {
                    detected: true,
                    level: detectedGrab,
                    price: detectedGrab.price,
                    details: `Resistance at $${formatNumber(detectedGrab.price)} was breached and then reclaimed`
                };
            } else {
                return {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'No liquidity grab detected for resistance levels'
                };
            }
        }
        
        // Format price with appropriate decimals
        function formatPriceForLevels(price) {
            if (price >= 1000) return price.toFixed(2);
            if (price >= 100) return price.toFixed(3);
            if (price >= 10) return price.toFixed(4);
            if (price >= 1) return price.toFixed(5);
            if (price >= 0.1) return price.toFixed(6);
            return price.toFixed(8);
        }
        
        // Format percentage for levels
        function formatPercentForLevels(price, currentPrice) {
            const percent = ((price - currentPrice) / currentPrice * 100);
            return {
                value: Math.abs(percent).toFixed(2),
                isPositive: percent >= 0
            };
        }
        
        // Calculate Daily CPR (Central Pivot Range) - Using EXACT PineScript formulas
        function calculateDailyCPR(dailyKlines, currentPrice) {
            if (!dailyKlines || dailyKlines.length < 2) {
                return {
                    tc: 0,
                    cp: 0,
                    bc: 0,
                    position: 'insufficient data',
                    priceVsCPR: 0,
                    range: 0
                };
            }
            
            // IMPORTANT: The PineScript indicator uses PREVIOUS DAY'S data for today's CPR
            // The PineScript uses: request.security(syminfo.tickerid, 'D', pivot[1], ...)
            // The [1] means previous bar in PineScript, so we need the previous day's data
            // The dailyKlines array is in chronological order (oldest first)
            // We need the second to last candle (index dailyKlines.length - 2) for previous day
            
            let prevDayIndex = dailyKlines.length - 2;
            
            // Safety check: if we don't have at least 2 days, use the oldest we have
            if (prevDayIndex < 0) {
                prevDayIndex = 0;
            }
            
            const prevDay = dailyKlines[prevDayIndex];
            
            const high = parseFloat(prevDay.high);
            const low = parseFloat(prevDay.low);
            const close = parseFloat(prevDay.close);
            
            // EXACT formulas from PineScript - must match exactly
            const pivot = (high + low + close) / 3;  // Central Pivot (CP)
            const bc = (high + low) / 2;             // Bottom Central (BC)
            const tc = pivot - bc + pivot;           // Top Central (TC)
            
            // Calculate additional support and resistance levels (for reference)
            const s1 = pivot * 2 - high;
            const s2 = pivot - (high - low);
            const s3 = low - 2 * (high - pivot);
            const r1 = pivot * 2 - low;
            const r2 = pivot + (high - low);
            const r3 = high + 2 * (pivot - low);
            
            // Determine position relative to CPR
            let position = 'inside';
            let priceVsCPR = 0;
            let range = tc - bc;
            
            if (currentPrice > tc) {
                position = 'above';
                priceVsCPR = ((currentPrice - tc) / tc) * 100;
            } else if (currentPrice < bc) {
                position = 'below';
                priceVsCPR = ((bc - currentPrice) / currentPrice) * 100;
            } else {
                position = 'inside';
                // Calculate how far inside the CPR (percentage from BC to TC)
                if (range > 0) {
                    priceVsCPR = ((currentPrice - bc) / range) * 100;
                }
            }
            
            return {
                tc: parseFloat(tc.toFixed(4)),
                cp: parseFloat(pivot.toFixed(4)),
                bc: parseFloat(bc.toFixed(4)),
                s1: parseFloat(s1.toFixed(4)),
                s2: parseFloat(s2.toFixed(4)),
                s3: parseFloat(s3.toFixed(4)),
                r1: parseFloat(r1.toFixed(4)),
                r2: parseFloat(r2.toFixed(4)),
                r3: parseFloat(r3.toFixed(4)),
                position: position,
                priceVsCPR: parseFloat(priceVsCPR.toFixed(2)),
                range: parseFloat(range.toFixed(4))
            };
        }
        
        // Calculate Support Convergence with CPR
        function calculateSupportConvergence(supportLevels, flippedLevels, cprData) {
            const allSupports = [...supportLevels, ...flippedLevels];
            const cprLevels = [
                { price: cprData.tc, type: 'TC' },
                { price: cprData.cp, type: 'CP' },
                { price: cprData.bc, type: 'BC' }
            ];
            
            let closestConvergence = null;
            let minDifference = Infinity;
            let convergenceType = '';
            let convergenceCPRType = '';
            let convergencePrice = 0;
            let convergenceSupportPrice = 0;
            
            // Check each support level against each CPR level
            for (const support of allSupports) {
                for (const cprLevel of cprLevels) {
                    if (cprLevel.price <= 0) continue; // Skip invalid CPR levels
                    
                    const difference = Math.abs(support.price - cprLevel.price);
                    const percentDifference = (difference / cprLevel.price) * 100;
                    
                    // Check if within 0.5% or overlapping
                    if (percentDifference <= 0.5) {
                        if (difference < minDifference) {
                            minDifference = difference;
                            closestConvergence = support;
                            convergenceType = support.type;
                            convergenceCPRType = cprLevel.type;
                            convergenceSupportPrice = support.price;
                            
                            // Calculate the middle point if they're close but not exactly the same
                            if (difference > 0) {
                                convergencePrice = (support.price + cprLevel.price) / 2;
                            } else {
                                convergencePrice = support.price; // Exact overlap
                            }
                        }
                    }
                }
            }
            
            if (closestConvergence) {
                return {
                    status: 'Solid Support',
                    price: parseFloat(convergencePrice.toFixed(4)),
                    supportType: convergenceType,
                    cprType: convergenceCPRType,
                    differencePercent: parseFloat((minDifference / convergencePrice * 100).toFixed(2)),
                    supportPrice: parseFloat(convergenceSupportPrice.toFixed(4))
                };
            } else {
                return {
                    status: 'No Convergence',
                    price: null,
                    supportType: '',
                    cprType: '',
                    differencePercent: 0,
                    supportPrice: null
                };
            }
        }
        
        // NEW: Calculate Resistance Convergence with CPR
        function calculateResistanceConvergence(resistanceLevels, flippedResistanceLevels, cprData) {
            const allResistances = [...resistanceLevels, ...flippedResistanceLevels];
            const cprLevels = [
                { price: cprData.tc, type: 'TC' },
                { price: cprData.cp, type: 'CP' },
                { price: cprData.bc, type: 'BC' }
            ];
            
            let closestConvergence = null;
            let minDifference = Infinity;
            let convergenceType = '';
            let convergenceCPRType = '';
            let convergencePrice = 0;
            let convergenceResistancePrice = 0;
            
            // Check each resistance level against each CPR level
            for (const resistance of allResistances) {
                for (const cprLevel of cprLevels) {
                    if (cprLevel.price <= 0) continue; // Skip invalid CPR levels
                    
                    const difference = Math.abs(resistance.price - cprLevel.price);
                    const percentDifference = (difference / cprLevel.price) * 100;
                    
                    // Check if within 0.5% or overlapping
                    if (percentDifference <= 0.5) {
                        if (difference < minDifference) {
                            minDifference = difference;
                            closestConvergence = resistance;
                            convergenceType = resistance.type;
                            convergenceCPRType = cprLevel.type;
                            convergenceResistancePrice = resistance.price;
                            
                            // Calculate the middle point if they're close but not exactly the same
                            if (difference > 0) {
                                convergencePrice = (resistance.price + cprLevel.price) / 2;
                            } else {
                                convergencePrice = resistance.price; // Exact overlap
                            }
                        }
                    }
                }
            }
            
            if (closestConvergence) {
                return {
                    status: 'Solid Resistance',
                    price: parseFloat(convergencePrice.toFixed(4)),
                    resistanceType: convergenceType,
                    cprType: convergenceCPRType,
                    differencePercent: parseFloat((minDifference / convergencePrice * 100).toFixed(2)),
                    resistancePrice: parseFloat(convergenceResistancePrice.toFixed(4))
                };
            } else {
                return {
                    status: 'No Convergence',
                    price: null,
                    resistanceType: '',
                    cprType: '',
                    differencePercent: 0,
                    resistancePrice: null
                };
            }
        }
        
        // Calculate VWAP with bands (Session anchor, Source: (H+L+C)/3, Bands: Standard Deviation, Std Dev: 1)
        function calculateVWAP(klines, currentPrice) {
            if (!klines || klines.length < 20) {
                return {
                    vwap: 0,
                    upperBand: 0,
                    lowerBand: 0,
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: 'insufficient data',
                    standardDeviation: 0
                };
            }
            
            // Get today's UTC date for session anchor (daily session)
            const now = new Date();
            const startOfDay = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0);
            
            // Filter candles for current session (today)
            let sessionCandles = klines.filter(k => k.time >= startOfDay);
            
            if (sessionCandles.length < 5) {
                // If not enough data for today, use last 24 hours as session
                const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
                sessionCandles = klines.filter(k => k.time >= twentyFourHoursAgo);
            }
            
            if (sessionCandles.length < 5) {
                // Still not enough data, use all available candles
                sessionCandles = klines.slice(-50);
            }
            
            // Calculate cumulative VWAP
            let cumulativeTPV = 0; // Cumulative Typical Price * Volume
            let cumulativeVolume = 0;
            const typicalPrices = [];
            
            for (const candle of sessionCandles) {
                // Source: (High + Low + Close) / 3
                const typicalPrice = (candle.high + candle.low + candle.close) / 3;
                typicalPrices.push(typicalPrice);
                
                cumulativeTPV += typicalPrice * candle.volume;
                cumulativeVolume += candle.volume;
            }
            
            if (cumulativeVolume === 0) {
                return {
                    vwap: 0,
                    upperBand: 0,
                    lowerBand: 0,
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: 'insufficient data',
                    standardDeviation: 0
                };
            }
            
            const vwap = cumulativeTPV / cumulativeVolume;
            
            // Calculate standard deviation of typical prices from VWAP
            let sumSquaredDifferences = 0;
            for (const tp of typicalPrices) {
                sumSquaredDifferences += Math.pow(tp - vwap, 2);
            }
            
            const standardDeviation = Math.sqrt(sumSquaredDifferences / typicalPrices.length);
            
            // Calculate bands (1 standard deviation)
            const upperBand = vwap + (1 * standardDeviation);
            const lowerBand = vwap - (1 * standardDeviation);
            
            // Calculate percentage distances with correct sign
            // Price ABOVE VWAP/UPPER/LOWER = Positive percentage
            // Price BELOW VWAP/UPPER/LOWER = Negative percentage
            const distanceFromVWAP = ((currentPrice - vwap) / vwap) * 100;
            const distanceFromUpperBand = ((currentPrice - upperBand) / upperBand) * 100;
            const distanceFromLowerBand = ((currentPrice - lowerBand) / lowerBand) * 100;
            
            // Determine position relative to VWAP
            let position = 'near';
            if (currentPrice > upperBand) {
                position = 'above';
            } else if (currentPrice < lowerBand) {
                position = 'below';
            } else if (Math.abs(distanceFromVWAP) > 0.5) {
                position = currentPrice > vwap ? 'above' : 'below';
            } else {
                position = 'near';
            }
            
            return {
                vwap: parseFloat(vwap.toFixed(6)),
                upperBand: parseFloat(upperBand.toFixed(6)),
                lowerBand: parseFloat(lowerBand.toFixed(6)),
                distanceFromVWAP: parseFloat(distanceFromVWAP.toFixed(2)),
                distanceFromUpperBand: parseFloat(distanceFromUpperBand.toFixed(2)),
                distanceFromLowerBand: parseFloat(distanceFromLowerBand.toFixed(2)),
                position: position,
                standardDeviation: parseFloat(standardDeviation.toFixed(6)),
                candlesUsed: sessionCandles.length
            };
        }
        
        // Calculate Indicator Summary
        function calculateIndicatorSummary(data, currentPrice) {
            const summary = {
                macd: {
                    status: data.macdAnalysis?.status || 'neutral',
                    histogram: data.macdAnalysis?.histogram || 0
                },
                crossover: {
                    type: data.macdAnalysis?.crossover || 'none',
                    strength: data.macdAnalysis?.crossoverStrength || 0,
                    periodsAgo: data.macdAnalysis?.crossoverPeriodsAgo || 0
                },
                volumeSpike: {
                    spike: data.volumeSpike?.spike || false,
                    multiple: data.volumeSpike?.multiple || 0
                },
                atr: {
                    volatility: data.atrAnalysis?.volatility || 'low',
                    atrPercentage: data.atrAnalysis?.atrPercentage || 0
                },
                obv: {
                    trend: data.obvAnalysis?.trend || 'neutral',
                    obvChange: data.obvAnalysis?.obvChange || 0
                },
                ichimoku: {
                    cloudPosition: data.ichimokuAnalysis?.cloudPosition || 'inside',
                    priceVsCloud: data.ichimokuAnalysis?.priceVsCloud || 0
                },
                ema: {
                    position: data.emaAnalysis?.position || 'cross',
                    differencePercentage: data.emaAnalysis?.differencePercentage || 0
                },
                supportLevels: {
                    closestDistance: 0,
                    percentage: 0,
                    hasLevels: (data.supportLevels && data.supportLevels.length > 0) ? true : false
                },
                flippedSupport: {
                    closestDistance: 0,
                    percentage: 0,
                    hasLevels: (data.flippedLevels && data.flippedLevels.length > 0) ? true : false
                },
                resistanceLevels: {
                    closestDistance: 0,
                    percentage: 0,
                    hasLevels: (data.resistanceLevels && data.resistanceLevels.length > 0) ? true : false
                },
                flippedResistance: {
                    closestDistance: 0,
                    percentage: 0,
                    hasLevels: (data.flippedResistanceLevels && data.flippedResistanceLevels.length > 0) ? true : false
                },
                cpr: {
                    tcPercentage: 0,
                    cpPercentage: 0,
                    bcPercentage: 0,
                    position: data.cprAnalysis?.position || 'inside'
                },
                vwap: {
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: data.vwapAnalysis?.position || 'near'
                },
                correlation: {
                    strength: data.correlationWithBTC?.strength || 'unknown',
                    percentage: data.correlationWithBTC?.percentage || 0,
                    independence: data.correlationWithBTC?.independence || 0
                },
                supportConvergence: {
                    status: data.supportConvergence?.status || 'No Convergence'
                },
                resistanceConvergence: {
                    status: data.resistanceConvergence?.status || 'No Convergence' // NEW
                },
                liquidityGrabSupport: {
                    detected: data.liquidityGrabSupport?.detected || false
                },
                liquidityGrabResistance: {
                    detected: data.liquidityGrabResistance?.detected || false
                }
            };
            
            // Calculate support level percentages
            if (summary.supportLevels.hasLevels && data.supportLevels.length > 0) {
                const closestSupport = data.supportLevels.reduce((closest, level) => {
                    const distance = Math.abs(level.price - currentPrice);
                    return distance < closest.distance ? { price: level.price, distance } : closest;
                }, { price: data.supportLevels[0].price, distance: Math.abs(data.supportLevels[0].price - currentPrice) });
                
                summary.supportLevels.closestDistance = closestSupport.distance;
                summary.supportLevels.percentage = parseFloat(((closestSupport.price - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate flipped support percentages
            if (summary.flippedSupport.hasLevels && data.flippedLevels.length > 0) {
                const closestFlipped = data.flippedLevels.reduce((closest, level) => {
                    const distance = Math.abs(level.price - currentPrice);
                    return distance < closest.distance ? { price: level.price, distance } : closest;
                }, { price: data.flippedLevels[0].price, distance: Math.abs(data.flippedLevels[0].price - currentPrice) });
                
                summary.flippedSupport.closestDistance = closestFlipped.distance;
                summary.flippedSupport.percentage = parseFloat(((closestFlipped.price - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate resistance level percentages
            if (summary.resistanceLevels.hasLevels && data.resistanceLevels.length > 0) {
                const closestResistance = data.resistanceLevels.reduce((closest, level) => {
                    const distance = Math.abs(level.price - currentPrice);
                    return distance < closest.distance ? { price: level.price, distance } : closest;
                }, { price: data.resistanceLevels[0].price, distance: Math.abs(data.resistanceLevels[0].price - currentPrice) });
                
                summary.resistanceLevels.closestDistance = closestResistance.distance;
                summary.resistanceLevels.percentage = parseFloat(((closestResistance.price - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate flipped resistance percentages
            if (summary.flippedResistance.hasLevels && data.flippedResistanceLevels.length > 0) {
                const closestFlippedResistance = data.flippedResistanceLevels.reduce((closest, level) => {
                    const distance = Math.abs(level.price - currentPrice);
                    return distance < closest.distance ? { price: level.price, distance } : closest;
                }, { price: data.flippedResistanceLevels[0].price, distance: Math.abs(data.flippedResistanceLevels[0].price - currentPrice) });
                
                summary.flippedResistance.closestDistance = closestFlippedResistance.distance;
                summary.flippedResistance.percentage = parseFloat(((closestFlippedResistance.price - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate CPR percentages
            if (data.cprAnalysis && data.cprAnalysis.tc > 0) {
                summary.cpr.tcPercentage = parseFloat(((data.cprAnalysis.tc - currentPrice) / currentPrice * 100).toFixed(2));
                summary.cpr.cpPercentage = parseFloat(((data.cprAnalysis.cp - currentPrice) / currentPrice * 100).toFixed(2));
                summary.cpr.bcPercentage = parseFloat(((data.cprAnalysis.bc - currentPrice) / currentPrice * 100).toFixed(2));
            }
            
            // Calculate VWAP distances
            if (data.vwapAnalysis) {
                summary.vwap.distanceFromVWAP = data.vwapAnalysis.distanceFromVWAP || 0;
                summary.vwap.distanceFromUpperBand = data.vwapAnalysis.distanceFromUpperBand || 0;
                summary.vwap.distanceFromLowerBand = data.vwapAnalysis.distanceFromLowerBand || 0;
                summary.vwap.position = data.vwapAnalysis.position || 'near';
            }
            
            return summary;
        }
        
        // Setup WebSocket connections for real-time price updates
        function setupWebSocketConnections() {
            SYMBOLS.forEach(symbol => {
                setupWebSocketForSymbol(symbol);
            });
        }
        
        function setupWebSocketForSymbol(symbol) {
            if (wsConnections[symbol]) {
                try {
                    wsConnections[symbol].close();
                } catch (e) {
                    console.log(`Error closing existing WebSocket for ${symbol}:`, e);
                }
            }
            
            const ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@ticker`);
            
            ws.onopen = () => {
                console.log(`WebSocket connected for ${symbol}`);
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    const currentPrice = parseFloat(data.c);
                    const symbol = data.s;
                    
                    if (cryptoData[symbol]) {
                        const previousPrice = cryptoData[symbol].currentPrice;
                        const change = currentPrice - previousPrice;
                        
                        cryptoData[symbol].currentPrice = currentPrice;
                        cryptoData[symbol].priceChange = change;
                        
                        // Recalculate VWAP with new price
                        if (cryptoData[symbol].indicatorKlines) {
                            cryptoData[symbol].vwapAnalysis = calculateVWAP(cryptoData[symbol].indicatorKlines, currentPrice);
                        }
                        
                        // Recalculate indicator summary with new price
                        cryptoData[symbol].indicatorSummary = calculateIndicatorSummary(cryptoData[symbol], currentPrice);
                        
                        const now = Date.now();
                        if (!lastUpdateTimes[symbol] || now - lastUpdateTimes[symbol] >= WS_UPDATE_THROTTLE) {
                            updatePriceCell(symbol, currentPrice, change);
                            updateVWAPCell(symbol, cryptoData[symbol].vwapAnalysis, currentPrice);
                            updateIndicatorSummary1Cell(symbol, cryptoData[symbol].indicatorSummary);
                            updateIndicatorSummary2Cell(symbol, cryptoData[symbol].indicatorSummary);
                            updateIndicatorSummary3Cell(symbol, cryptoData[symbol].indicatorSummary);
                            lastUpdateTimes[symbol] = now;
                        }
                        
                        lastPrices[symbol] = currentPrice;
                    }
                } catch (error) {
                    console.error(`Error processing WebSocket message for ${symbol}:`, error);
                }
            };
            
            ws.onerror = (error) => {
                console.error(`WebSocket error for ${symbol}:`, error);
            };
            
            ws.onclose = () => {
                console.log(`WebSocket closed for ${symbol}, attempting to reconnect in 5 seconds...`);
                setTimeout(() => {
                    setupWebSocketForSymbol(symbol);
                }, 5000);
            };
            
            wsConnections[symbol] = ws;
        }
        
        // Close all WebSocket connections
        function closeAllWebSocketConnections() {
            SYMBOLS.forEach(symbol => {
                if (wsConnections[symbol]) {
                    try {
                        wsConnections[symbol].close();
                    } catch (e) {
                        console.log(`Error closing WebSocket for ${symbol}:`, e);
                    }
                    delete wsConnections[symbol];
                }
            });
        }
        
        // Show app selection modal
        function showAppModal(symbol) {
            currentSymbolForLink = symbol;
            appModal.style.display = 'flex';
        }
        
        // Hide app selection modal
        function hideAppModal() {
            appModal.style.display = 'none';
            currentSymbolForLink = null;
        }
        
        // Generate TradingView deep link for mobile app
        function getTradingViewAppLink(symbol) {
            const tvSymbol = `BINANCE:${symbol}`;
            return `tradingview://chart/?symbol=${tvSymbol}&interval=60`;
        }
        
        // Generate TradingView web link
        function getTradingViewWebLink(symbol) {
            const tvSymbol = `BINANCE:${symbol}`;
            return `https://www.tradingview.com/chart/?symbol=${tvSymbol}&interval=60`;
        }
        
        // Open TradingView app with improved method
        function openTradingViewApp(symbol) {
            const appLink = getTradingViewAppLink(symbol);
            const webLink = getTradingViewWebLink(symbol);
            
            window.location.href = appLink;
            
            setTimeout(function() {
                window.open(webLink, '_blank');
            }, 500);
            
            setTimeout(function() {
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = appLink;
                document.body.appendChild(iframe);
                
                setTimeout(function() {
                    document.body.removeChild(iframe);
                }, 1000);
            }, 100);
        }
        
        // Open TradingView web
        function openTradingViewWeb(symbol) {
            const webLink = getTradingViewWebLink(symbol);
            window.open(webLink, '_blank');
        }
        
        // Handle TradingView link click
        function handleTradingViewClick(symbol, event) {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                event.preventDefault();
                showAppModal(symbol);
                return false;
            } else {
                openTradingViewWeb(symbol);
                event.preventDefault();
                return false;
            }
        }
        
        // Load watchlist from localStorage
        function loadWatchlist() {
            const savedWatchlist = localStorage.getItem('cryptoWatchlist');
            if (savedWatchlist) {
                try {
                    const watchlistArray = JSON.parse(savedWatchlist);
                    watchlist = new Set(watchlistArray);
                } catch (e) {
                    console.error('Error loading watchlist:', e);
                    watchlist = new Set();
                }
            }
        }
        
        // Save watchlist to localStorage
        function saveWatchlist() {
            const watchlistArray = Array.from(watchlist);
            localStorage.setItem('cryptoWatchlist', JSON.stringify(watchlistArray));
        }
        
        // Toggle symbol in watchlist
        function toggleWatchlist(symbol) {
            if (watchlist.has(symbol)) {
                watchlist.delete(symbol);
            } else {
                watchlist.add(symbol);
            }
            saveWatchlist();
            updateWatchlistCount();
            
            updateStarIcon(symbol);
            
            if (currentView === 'watchlist' && watchlist.size === 0) {
                setActiveView('all');
            }
            
            if (currentView === 'watchlist') {
                updateTable();
            }
        }
        
        // Update star icon for a specific symbol
        function updateStarIcon(symbol) {
            const starElement = document.querySelector(`.watchlist-star[data-symbol="${symbol}"]`);
            if (starElement) {
                if (watchlist.has(symbol)) {
                    starElement.classList.add('active');
                    starElement.innerHTML = '<i class="fas fa-star"></i>';
                } else {
                    starElement.classList.remove('active');
                    starElement.innerHTML = '<i class="far fa-star"></i>';
                }
            }
        }
        
        // Update watchlist count display
        function updateWatchlistCount() {
            const count = watchlist.size;
            watchlistCount.textContent = count;
            watchlistBadge.textContent = count;
            
            if (count > 0) {
                watchlistCountDisplay.style.display = 'inline-block';
            } else {
                watchlistCountDisplay.style.display = 'none';
            }
        }
        
        // Set active view
        function setActiveView(view) {
            currentView = view;
            
            if (view === 'all') {
                viewAllBtn.classList.add('active');
                viewWatchlistBtn.classList.remove('active');
            } else {
                viewAllBtn.classList.remove('active');
                viewWatchlistBtn.classList.add('active');
            }
        }
        
        // Update the last updated time display
        function updateTimeDisplay() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            lastUpdatedTime.textContent = timeString;
        }
        
        // Fetch all historical data (klines) for indicators
        async function fetchAllHistoricalData() {
            if (isUpdating) return;
            
            isUpdating = true;
            clearError();
            
            try {
                const promises = SYMBOLS.map(symbol => fetchHistoricalData(symbol));
                const results = await Promise.allSettled(promises);
                
                const failed = results.filter(r => r.status === 'rejected');
                if (failed.length > 0) {
                    console.error('Some historical data requests failed:', failed);
                    if (failed.length === SYMBOLS.length) {
                        throw new Error('Unable to fetch historical data from Binance API');
                    }
                }
                
                // For correlation, we need 1-hour BTC prices in both modes
                if (cryptoData['BTCUSDT'] && cryptoData['BTCUSDT'].correlationKlines) {
                    btcHourlyPrices = cryptoData['BTCUSDT'].correlationKlines
                        .slice(-CORRELATION_PERIOD)
                        .map(k => k.close);
                }
                
                calculateAllCorrelations();
                
                updateTable();
                applyFilters(); // Apply filters after data is loaded
            } catch (error) {
                console.error('Error fetching historical data:', error);
                showError(`Connection error: ${error.message}. Trying again...`);
            } finally {
                isUpdating = false;
            }
        }
        
        // Calculate correlations for all symbols with BTC
        function calculateAllCorrelations() {
            if (btcHourlyPrices.length < 10) {
                return;
            }
            
            Object.keys(cryptoData).forEach(symbol => {
                if (symbol === 'BTCUSDT') {
                    cryptoData[symbol].correlationWithBTC = {
                        correlation: 1.0,
                        percentage: 100,
                        strength: 'high',
                        independence: 0,
                        trend: 'perfect'
                    };
                    return;
                }
                
                const data = cryptoData[symbol];
                if (data && data.correlationKlines && data.correlationKlines.length >= 10) {
                    const correlation = calculateCorrelationWithBTC(data.correlationKlines);
                    cryptoData[symbol].correlationWithBTC = correlation;
                } else {
                    cryptoData[symbol].correlationWithBTC = {
                        correlation: 0,
                        percentage: 0,
                        strength: 'unknown',
                        independence: 100,
                        trend: 'unknown'
                    };
                }
                
                // Calculate indicator summary
                if (data && data.currentPrice) {
                    cryptoData[symbol].indicatorSummary = calculateIndicatorSummary(data, data.currentPrice);
                }
            });
        }
        
        // Calculate correlation with BTC
        function calculateCorrelationWithBTC(correlationKlines) {
            if (correlationKlines.length < 10 || btcHourlyPrices.length < 10) {
                return {
                    correlation: 0,
                    percentage: 0,
                    strength: 'insufficient data',
                    independence: 100,
                    trend: 'unknown'
                };
            }
            
            const coinPrices = correlationKlines
                .slice(-CORRELATION_PERIOD)
                .map(k => k.close);
            
            const minLength = Math.min(coinPrices.length, btcHourlyPrices.length);
            const coinSlice = coinPrices.slice(-minLength);
            const btcSlice = btcHourlyPrices.slice(-minLength);
            
            if (minLength < 10) {
                return {
                    correlation: 0,
                    percentage: 0,
                    strength: 'insufficient data',
                    independence: 100,
                    trend: 'unknown'
                };
            }
            
            const correlation = calculatePearsonCorrelation(coinSlice, btcSlice);
            const percentage = Math.abs(correlation * 100);
            
            let strength = 'low';
            if (percentage >= 70) {
                strength = 'high';
            } else if (percentage >= 30) {
                strength = 'medium';
            } else {
                strength = 'low';
            }
            
            const independence = 100 - percentage;
            
            let trend = 'neutral';
            if (correlation > 0.5) {
                trend = 'positive';
            } else if (correlation < -0.5) {
                trend = 'negative';
            } else if (correlation > 0) {
                trend = 'weakly positive';
            } else if (correlation < 0) {
                trend = 'weakly negative';
            } else {
                trend = 'no correlation';
            }
            
            return {
                correlation: parseFloat(correlation.toFixed(3)),
                percentage: parseFloat(percentage.toFixed(1)),
                strength: strength,
                independence: parseFloat(independence.toFixed(1)),
                trend: trend
            };
        }
        
        // Calculate Pearson correlation coefficient
        function calculatePearsonCorrelation(x, y) {
            const n = x.length;
            
            const meanX = x.reduce((a, b) => a + b, 0) / n;
            const meanY = y.reduce((a, b) => a + b, 0) / n;
            
            let numerator = 0;
            let denomX = 0;
            let denomY = 0;
            
            for (let i = 0; i < n; i++) {
                const diffX = x[i] - meanX;
                const diffY = y[i] - meanY;
                
                numerator += diffX * diffY;
                denomX += diffX * diffX;
                denomY += diffY * diffY;
            }
            
            if (denomX === 0 || denomY === 0) {
                return 0;
            }
            
            const correlation = numerator / Math.sqrt(denomX * denomY);
            
            return Math.max(-1, Math.min(1, correlation));
        }
        
        // Fetch historical data for a specific cryptocurrency with timeframe mode support
        async function fetchHistoricalData(symbol) {
            try {
                // Get initial price from ticker API
                const priceResponse = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
                if (!priceResponse.ok) throw new Error(`Failed to fetch price for ${symbol}`);
                const priceData = await priceResponse.json();
                
                const currentPrice = parseFloat(priceData.price);
                
                // Determine intervals based on current timeframe
                let swingInterval, indicatorInterval, correlationInterval;
                
                if (currentTimeframe === '1h') {
                    // 1-hour mode
                    swingInterval = '4h'; // Swing pattern uses 4h
                    indicatorInterval = '1h'; // Most indicators use 1h
                    correlationInterval = '1h'; // Correlation uses 1h
                } else {
                    // 4-hour mode
                    swingInterval = '12h'; // Swing pattern uses 12h
                    indicatorInterval = '4h'; // Most indicators use 4h
                    correlationInterval = '1h'; // Correlation still uses 1h
                }
                
                // Get swing kline data (for swing pattern and ATR)
                const swingKlineResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${swingInterval}&limit=${CANDLE_LIMIT}`);
                if (!swingKlineResponse.ok) throw new Error(`Failed to fetch ${swingInterval} kline data for ${symbol}`);
                const swingKlineData = await swingKlineResponse.json();
                
                // Get indicator kline data (for most technical indicators)
                const indicatorKlineResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${indicatorInterval}&limit=${MACD_CANDLE_LIMIT}`);
                if (!indicatorKlineResponse.ok) throw new Error(`Failed to fetch ${indicatorInterval} kline data for ${symbol}`);
                const indicatorKlineData = await indicatorKlineResponse.json();
                
                // Get correlation kline data (1-hour for correlation with BTC)
                const correlationKlineResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=${CORRELATION_PERIOD + 10}`);
                if (!correlationKlineResponse.ok) throw new Error(`Failed to fetch 1h correlation kline data for ${symbol}`);
                const correlationKlineData = await correlationKlineResponse.json();
                
                // Get daily kline data for CPR calculation
                const dailyKlineResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1d&limit=5`);
                if (!dailyKlineResponse.ok) throw new Error(`Failed to fetch daily kline data for ${symbol}`);
                const dailyKlineData = await dailyKlineResponse.json();
                
                // Process swing candles
                const swingKlines = swingKlineData.map(k => ({
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    time: k[0],
                    volume: parseFloat(k[5])
                }));
                
                // Process indicator candles
                const indicatorKlines = indicatorKlineData.map(k => ({
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    time: k[0],
                    volume: parseFloat(k[5])
                }));
                
                // Process correlation candles (1-hour)
                const correlationKlines = correlationKlineData.map(k => ({
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    time: k[0],
                    volume: parseFloat(k[5])
                }));
                
                // Process daily candles for CPR calculation
                const dailyKlines = dailyKlineData.map(k => ({
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    time: k[0],
                    volume: parseFloat(k[5])
                }));
                
                // Calculate swing pattern (using swingKlines)
                const swingPattern = calculateSwingPattern(swingKlines, currentPrice);
                
                // Calculate MACD status with crossover detection (using indicatorKlines)
                const macdAnalysis = calculateMACDWithCrossover(indicatorKlines);
                
                // Calculate volume spike (using indicatorKlines)
                const volumeSpike = calculateVolumeSpike(indicatorKlines);
                
                // Calculate ATR volatility (using swingKlines)
                const atrAnalysis = calculateATRVolatility(swingKlines, currentPrice);
                
                // Calculate OBV (On Balance Volume) trend (using indicatorKlines)
                const obvAnalysis = calculateOBVTrend(indicatorKlines);
                
                // Calculate Ichimoku Cloud position (using indicatorKlines)
                const ichimokuAnalysis = calculateIchimokuCloud(indicatorKlines, currentPrice);
                
                // Calculate EMA analysis with current period (using indicatorKlines)
                const emaAnalysis = calculateEMAAnalysis(indicatorKlines, currentPrice, currentEMAPeriod);
                
                // Calculate support levels, flipped support, resistance levels, and flipped resistance (using indicatorKlines)
                const marketStructure = calculateMarketStructure(indicatorKlines, currentPrice);
                
                // Calculate Liquidity Grab (Support)
                const liquidityGrabSupport = calculateLiquidityGrabSupport(marketStructure.supportLevels, indicatorKlines, currentPrice);
                
                // Calculate Liquidity Grab (Resistance)
                const liquidityGrabResistance = calculateLiquidityGrabResistance(marketStructure.resistanceLevels, indicatorKlines, currentPrice);
                
                // Calculate Daily CPR (Central Pivot Range)
                const cprAnalysis = calculateDailyCPR(dailyKlines, currentPrice);
                
                // Calculate Support Convergence with CPR
                const supportConvergence = calculateSupportConvergence(
                    marketStructure.supportLevels, 
                    marketStructure.flippedLevels, 
                    cprAnalysis
                );
                
                // NEW: Calculate Resistance Convergence with CPR
                const resistanceConvergence = calculateResistanceConvergence(
                    marketStructure.resistanceLevels,
                    marketStructure.flippedResistanceLevels,
                    cprAnalysis
                );
                
                // Calculate VWAP (Volume Weighted Average Price)
                const vwapAnalysis = calculateVWAP(indicatorKlines, currentPrice);
                
                // Calculate Indicator Summary
                const indicatorSummary = calculateIndicatorSummary({
                    macdAnalysis,
                    volumeSpike,
                    atrAnalysis,
                    obvAnalysis,
                    ichimokuAnalysis,
                    emaAnalysis,
                    supportLevels: marketStructure.supportLevels,
                    flippedLevels: marketStructure.flippedLevels,
                    resistanceLevels: marketStructure.resistanceLevels,
                    flippedResistanceLevels: marketStructure.flippedResistanceLevels,
                    cprAnalysis,
                    vwapAnalysis,
                    supportConvergence,
                    resistanceConvergence, // NEW
                    liquidityGrabSupport,
                    liquidityGrabResistance
                }, currentPrice);
                
                // Store data
                cryptoData[symbol] = {
                    symbol: symbol,
                    currentPrice: currentPrice,
                    swingPattern: swingPattern,
                    macdAnalysis: macdAnalysis,
                    volumeSpike: volumeSpike,
                    atrAnalysis: atrAnalysis,
                    obvAnalysis: obvAnalysis,
                    ichimokuAnalysis: ichimokuAnalysis,
                    emaAnalysis: emaAnalysis,
                    cprAnalysis: cprAnalysis,
                    supportConvergence: supportConvergence,
                    resistanceConvergence: resistanceConvergence, // NEW
                    supportLevels: marketStructure.supportLevels,
                    flippedLevels: marketStructure.flippedLevels,
                    resistanceLevels: marketStructure.resistanceLevels,
                    flippedResistanceLevels: marketStructure.flippedResistanceLevels,
                    liquidityGrabSupport: liquidityGrabSupport,
                    liquidityGrabResistance: liquidityGrabResistance,
                    vwapAnalysis: vwapAnalysis,
                    indicatorSummary: indicatorSummary,
                    indicatorKlines: indicatorKlines,
                    swingKlines: swingKlines,
                    correlationKlines: correlationKlines,
                    dailyKlines: dailyKlines,
                    lastUpdate: new Date()
                };
                
                // Determine if price went up or down for animation
                if (lastPrices[symbol]) {
                    const change = currentPrice - lastPrices[symbol];
                    cryptoData[symbol].priceChange = change;
                }
                
                lastPrices[symbol] = currentPrice;
                
                // Setup WebSocket if not already connected
                if (!wsConnections[symbol]) {
                    setupWebSocketForSymbol(symbol);
                }
                
            } catch (error) {
                console.error(`Error fetching historical data for ${symbol}:`, error);
                if (!cryptoData[symbol]) {
                    cryptoData[symbol] = createErrorData(symbol);
                }
            }
        }
        
        // Create error data structure
        function createErrorData(symbol) {
            return {
                symbol: symbol,
                currentPrice: 0,
                swingPattern: { 
                    pattern: 'error', 
                    percentage: 0,
                    breachedSwingPrice: 0,
                    swingType: 'none'
                },
                macdAnalysis: {
                    status: 'error',
                    macdLine: 0,
                    signalLine: 0,
                    histogram: 0,
                    crossover: 'none',
                    crossoverStrength: 0,
                    crossoverPeriodsAgo: 0
                },
                volumeSpike: {
                    spike: false,
                    multiple: 0,
                    volume: 0,
                    averageVolume: 0
                },
                atrAnalysis: {
                    atrValue: 0,
                    atrPercentage: 0,
                    volatility: 'error',
                    trueRange: 0,
                    priceChange24h: 0
                },
                obvAnalysis: {
                    trend: 'error',
                    obvValue: 0,
                    obvChange: 0,
                    trendStrength: 0,
                    volumeConfirmation: false
                },
                ichimokuAnalysis: {
                    cloudPosition: 'error',
                    conversionLine: 0,
                    baseLine: 0,
                    leadingSpanA: 0,
                    leadingSpanB: 0,
                    cloudTop: 0,
                    cloudBottom: 0,
                    priceVsCloud: 0
                },
                emaAnalysis: {
                    position: 'error',
                    emaValue: 0,
                    difference: 0,
                    differencePercentage: 0,
                    trend: 'neutral'
                },
                cprAnalysis: {
                    tc: 0,
                    cp: 0,
                    bc: 0,
                    position: 'error',
                    priceVsCPR: 0,
                    range: 0
                },
                supportConvergence: {
                    status: 'No Convergence',
                    price: null,
                    supportType: '',
                    cprType: '',
                    differencePercent: 0,
                    supportPrice: null
                },
                resistanceConvergence: { // NEW
                    status: 'No Convergence',
                    price: null,
                    resistanceType: '',
                    cprType: '',
                    differencePercent: 0,
                    resistancePrice: null
                },
                liquidityGrabSupport: {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Error calculating liquidity grab support'
                },
                liquidityGrabResistance: {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Error calculating liquidity grab resistance'
                },
                vwapAnalysis: {
                    vwap: 0,
                    upperBand: 0,
                    lowerBand: 0,
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: 'error',
                    standardDeviation: 0,
                    candlesUsed: 0
                },
                indicatorSummary: {
                    macd: { status: 'error', histogram: 0 },
                    crossover: { type: 'none', strength: 0, periodsAgo: 0 },
                    volumeSpike: { spike: false, multiple: 0 },
                    atr: { volatility: 'error', atrPercentage: 0 },
                    obv: { trend: 'error', obvChange: 0 },
                    ichimoku: { cloudPosition: 'error', priceVsCloud: 0 },
                    ema: { position: 'error', differencePercentage: 0 },
                    supportLevels: { closestDistance: 0, percentage: 0, hasLevels: false },
                    flippedSupport: { closestDistance: 0, percentage: 0, hasLevels: false },
                    resistanceLevels: { closestDistance: 0, percentage: 0, hasLevels: false },
                    flippedResistance: { closestDistance: 0, percentage: 0, hasLevels: false },
                    cpr: { tcPercentage: 0, cpPercentage: 0, bcPercentage: 0, position: 'error' },
                    vwap: { distanceFromVWAP: 0, distanceFromUpperBand: 0, distanceFromLowerBand: 0, position: 'error' },
                    correlation: { strength: 'error', percentage: 0, independence: 0 },
                    supportConvergence: { status: 'No Convergence' },
                    resistanceConvergence: { status: 'No Convergence' }, // NEW
                    liquidityGrabSupport: { detected: false },
                    liquidityGrabResistance: { detected: false }
                },
                supportLevels: [],
                flippedLevels: [],
                resistanceLevels: [],
                flippedResistanceLevels: [],
                correlationWithBTC: {
                    correlation: 0,
                    percentage: 0,
                    strength: 'error',
                    independence: 0,
                    trend: 'unknown'
                },
                lastUpdate: new Date()
            };
        }
        
        // Calculate EMA analysis
        function calculateEMAAnalysis(klines, currentPrice, period) {
            if (klines.length < period + 5) {
                return {
                    position: 'insufficient data',
                    emaValue: 0,
                    difference: 0,
                    differencePercentage: 0,
                    trend: 'neutral'
                };
            }
            
            const closingPrices = klines.map(k => k.close);
            const emaValues = calculateEMA(closingPrices, period);
            const latestEMA = emaValues[emaValues.length - 1];
            
            if (latestEMA === null) {
                return {
                    position: 'error',
                    emaValue: 0,
                    difference: 0,
                    differencePercentage: 0,
                    trend: 'neutral'
                };
            }
            
            const difference = currentPrice - latestEMA;
            const differencePercentage = (difference / latestEMA) * 100;
            
            let position = 'cross';
            let trend = 'neutral';
            
            if (differencePercentage > 0.5) {
                position = 'above';
                trend = 'bullish';
            } else if (differencePercentage < -0.5) {
                position = 'below';
                trend = 'bearish';
            } else {
                position = 'cross';
                trend = 'neutral';
            }
            
            const previousEMA = emaValues[emaValues.length - 2];
            let emaTrend = 'neutral';
            
            if (previousEMA !== null) {
                if (latestEMA > previousEMA) {
                    emaTrend = 'rising';
                } else if (latestEMA < previousEMA) {
                    emaTrend = 'falling';
                }
            }
            
            return {
                position: position,
                emaValue: parseFloat(latestEMA.toFixed(4)),
                difference: parseFloat(difference.toFixed(4)),
                differencePercentage: parseFloat(differencePercentage.toFixed(2)),
                trend: emaTrend
            };
        }
        
        // Calculate swing pattern from klines
        function calculateSwingPattern(klines, currentPrice) {
            if (klines.length < 10) {
                return { 
                    pattern: 'insufficient data', 
                    percentage: 0,
                    breachedSwingPrice: 0,
                    swingType: 'none'
                };
            }
            
            const swingHighs = [];
            const swingLows = [];
            
            for (let i = 3; i < klines.length - 3; i++) {
                let isSwingHigh = true;
                let isSwingLow = true;
                
                for (let j = 1; j <= 3; j++) {
                    if (klines[i].high <= klines[i - j].high || klines[i].high <= klines[i + j].high) {
                        isSwingHigh = false;
                    }
                    
                    if (klines[i].low >= klines[i - j].low || klines[i].low >= klines[i + j].low) {
                        isSwingLow = false;
                    }
                }
                
                if (isSwingHigh) {
                    swingHighs.push({
                        price: klines[i].high,
                        index: i,
                        time: klines[i].time
                    });
                }
                
                if (isSwingLow) {
                    swingLows.push({
                        price: klines[i].low,
                        index: i,
                        time: klines[i].time
                    });
                }
            }
            
            swingHighs.sort((a, b) => b.index - a.index);
            swingLows.sort((a, b) => b.index - a.index);
            
            let breachedSwing = null;
            let pattern = 'consolidation';
            let swingType = 'none';
            
            for (let swingHigh of swingHighs) {
                if (currentPrice > swingHigh.price) {
                    breachedSwing = swingHigh;
                    pattern = 'higher-high';
                    swingType = 'swing high';
                    break;
                }
            }
            
            if (!breachedSwing) {
                for (let swingLow of swingLows) {
                    if (currentPrice < swingLow.price) {
                        breachedSwing = swingLow;
                        pattern = 'lower-low';
                        swingType = 'swing low';
                        break;
                    }
                }
            }
            
            let percentage = 0;
            let breachedSwingPrice = 0;
            
            if (breachedSwing) {
                breachedSwingPrice = breachedSwing.price;
                
                if (pattern === 'higher-high') {
                    percentage = ((currentPrice - breachedSwingPrice) / breachedSwingPrice * 100);
                } else if (pattern === 'lower-low') {
                    percentage = ((breachedSwingPrice - currentPrice) / breachedSwingPrice * 100);
                }
            }
            
            return { 
                pattern: pattern, 
                percentage: parseFloat(percentage.toFixed(2)),
                breachedSwingPrice: breachedSwingPrice,
                swingType: swingType
            };
        }
        
        // Calculate MACD with crossover detection from candles
        function calculateMACDWithCrossover(klines) {
            if (klines.length < 40) {
                return {
                    status: 'insufficient data',
                    macdLine: 0,
                    signalLine: 0,
                    histogram: 0,
                    crossover: 'none',
                    crossoverStrength: 0,
                    crossoverPeriodsAgo: 0
                };
            }
            
            const closingPrices = klines.map(k => k.close);
            
            const ema12 = calculateEMA(closingPrices, 12);
            const ema26 = calculateEMA(closingPrices, 26);
            
            const macdLine = [];
            for (let i = 0; i < ema12.length; i++) {
                if (ema12[i] !== null && ema26[i] !== null) {
                    macdLine.push(ema12[i] - ema26[i]);
                } else {
                    macdLine.push(null);
                }
            }
            
            const validMACDLine = macdLine.filter(v => v !== null);
            const signalLine = calculateEMA(validMACDLine, 9);
            
            const latestMacdLine = macdLine[macdLine.length - 1];
            const latestSignalLine = signalLine[signalLine.length - 1];
            
            if (latestMacdLine !== null && latestSignalLine !== null) {
                const histogram = latestMacdLine - latestSignalLine;
                
                let status = 'neutral';
                
                if (latestMacdLine > latestSignalLine) {
                    status = 'positive';
                } else if (latestMacdLine < latestSignalLine) {
                    status = 'negative';
                } else {
                    status = 'neutral';
                }
                
                const crossover = detectMACDCrossover(macdLine, signalLine);
                
                return {
                    status: status,
                    macdLine: parseFloat(latestMacdLine.toFixed(6)),
                    signalLine: parseFloat(latestSignalLine.toFixed(6)),
                    histogram: parseFloat(histogram.toFixed(6)),
                    crossover: crossover.type,
                    crossoverStrength: crossover.strength,
                    crossoverPeriodsAgo: crossover.periodsAgo
                };
            }
            
            return {
                status: 'error',
                macdLine: 0,
                signalLine: 0,
                histogram: 0,
                crossover: 'none',
                crossoverStrength: 0,
                crossoverPeriodsAgo: 0
            };
        }
        
        // Detect MACD crossover in recent periods
        function detectMACDCrossover(macdLine, signalLine) {
            const validMacdIndices = [];
            const validSignalIndices = [];
            
            for (let i = macdLine.length - 1; i >= 0; i--) {
                if (macdLine[i] !== null) validMacdIndices.push(i);
                if (validMacdIndices.length >= 10) break;
            }
            
            for (let i = signalLine.length - 1; i >= 0; i--) {
                if (signalLine[i] !== null) validSignalIndices.push(i);
                if (validSignalIndices.length >= 10) break;
            }
            
            if (validMacdIndices.length < 3 || validSignalIndices.length < 3) {
                return { type: 'none', strength: 0, periodsAgo: 0 };
            }
            
            const recentMacdValues = [];
            const recentSignalValues = [];
            
            for (let i = 0; i < Math.min(5, validMacdIndices.length, validSignalIndices.length); i++) {
                const macdIdx = validMacdIndices[i];
                const signalIdx = validSignalIndices[i];
                
                if (macdLine[macdIdx] !== null && signalLine[signalIdx] !== null) {
                    recentMacdValues.push({ value: macdLine[macdIdx], index: macdIdx });
                    recentSignalValues.push({ value: signalLine[signalIdx], index: signalIdx });
                }
            }
            
            recentMacdValues.sort((a, b) => a.index - b.index);
            recentSignalValues.sort((a, b) => a.index - b.index);
            
            for (let i = Math.max(0, recentMacdValues.length - 3); i < recentMacdValues.length - 1; i++) {
                const currentMacd = recentMacdValues[i].value;
                const currentSignal = recentSignalValues[i].value;
                const nextMacd = recentMacdValues[i + 1].value;
                const nextSignal = recentSignalValues[i + 1].value;
                
                if (currentMacd <= currentSignal && nextMacd > nextSignal) {
                    const strength = Math.abs(nextMacd - nextSignal);
                    const periodsAgo = recentMacdValues.length - (i + 2);
                    return { type: 'bullish', strength: strength, periodsAgo: periodsAgo };
                }
                
                if (currentMacd >= currentSignal && nextMacd < nextSignal) {
                    const strength = Math.abs(nextMacd - nextSignal);
                    const periodsAgo = recentMacdValues.length - (i + 2);
                    return { type: 'bearish', strength: strength, periodsAgo: periodsAgo };
                }
            }
            
            return { type: 'none', strength: 0, periodsAgo: 0 };
        }
        
        // Calculate volume spike from candles
        function calculateVolumeSpike(klines) {
            if (klines.length < 21) {
                return {
                    spike: false,
                    multiple: 0,
                    volume: 0,
                    averageVolume: 0
                };
            }
            
            const closedCandles = klines.slice(-21, -1);
            
            if (closedCandles.length < 20) {
                return {
                    spike: false,
                    multiple: 0,
                    volume: 0,
                    averageVolume: 0
                };
            }
            
            const volumes = closedCandles.map(candle => candle.volume);
            const sum = volumes.reduce((a, b) => a + b, 0);
            const averageVolume = sum / volumes.length;
            
            const recentCandle = closedCandles[closedCandles.length - 1];
            const recentVolume = recentCandle.volume;
            
            const multiple = recentVolume / averageVolume;
            const spike = multiple >= 1.5;
            
            return {
                spike: spike,
                multiple: parseFloat(multiple.toFixed(1)),
                volume: recentVolume,
                averageVolume: averageVolume
            };
        }
        
        // Calculate ATR (Average True Range) volatility
        function calculateATRVolatility(klines, currentPrice) {
            if (klines.length < ATR_PERIOD + 5) {
                return {
                    atrValue: 0,
                    atrPercentage: 0,
                    volatility: 'insufficient data',
                    trueRange: 0,
                    priceChange24h: 0
                };
            }
            
            const trueRanges = [];
            
            for (let i = 1; i < klines.length; i++) {
                const current = klines[i];
                const previous = klines[i-1];
                
                const highLow = current.high - current.low;
                const highPrevClose = Math.abs(current.high - previous.close);
                const lowPrevClose = Math.abs(current.low - previous.close);
                
                const trueRange = Math.max(highLow, highPrevClose, lowPrevClose);
                trueRanges.push(trueRange);
            }
            
            if (trueRanges.length < ATR_PERIOD) {
                return {
                    atrValue: 0,
                    atrPercentage: 0,
                    volatility: 'insufficient data',
                    trueRange: 0,
                    priceChange24h: 0
                };
            }
            
            const recentTrueRanges = trueRanges.slice(-ATR_PERIOD);
            const atrValue = recentTrueRanges.reduce((sum, tr) => sum + tr, 0) / ATR_PERIOD;
            
            const atrPercentage = (atrValue / currentPrice) * 100;
            
            const currentTrueRange = trueRanges[trueRanges.length - 1] || 0;
            
            // Calculate 24h price change based on the timeframe
            let priceChange24h = 0;
            if (klines.length >= 24) {
                const price24hAgo = klines[klines.length - 24].close;
                priceChange24h = ((currentPrice - price24hAgo) / price24hAgo) * 100;
            } else if (klines.length > 0) {
                const priceStart = klines[0].close;
                priceChange24h = ((currentPrice - priceStart) / priceStart) * 100;
            }
            
            let volatility = 'low';
            
            if (atrPercentage >= 3.0) {
                volatility = 'high';
            } else if (atrPercentage >= 1.5) {
                volatility = 'moderate';
            } else if (atrPercentage >= 0.5) {
                volatility = 'good';
            } else {
                volatility = 'low';
            }
            
            return {
                atrValue: parseFloat(atrValue.toFixed(6)),
                atrPercentage: parseFloat(atrPercentage.toFixed(2)),
                volatility: volatility,
                trueRange: parseFloat(currentTrueRange.toFixed(6)),
                priceChange24h: parseFloat(priceChange24h.toFixed(2))
            };
        }
        
        // Calculate OBV (On Balance Volume) trend
        function calculateOBVTrend(klines) {
            if (klines.length < 10) {
                return {
                    trend: 'insufficient data',
                    obvValue: 0,
                    obvChange: 0,
                    trendStrength: 0,
                    volumeConfirmation: false
                };
            }
            
            let obv = 0;
            const obvValues = [];
            
            for (let i = 0; i < klines.length; i++) {
                const current = klines[i];
                const volume = current.volume;
                
                if (i === 0) {
                    obv = 0;
                } else {
                    const previous = klines[i-1];
                    
                    if (current.close > previous.close) {
                        obv += volume;
                    } else if (current.close < previous.close) {
                        obv -= volume;
                    }
                }
                
                obvValues.push(obv);
            }
            
            const recentOBVValues = obvValues.slice(-OBV_PERIOD);
            
            if (recentOBVValues.length < 5) {
                return {
                    trend: 'insufficient data',
                    obvValue: obv,
                    obvChange: 0,
                    trendStrength: 0,
                    volumeConfirmation: false
                };
            }
            
            const currentOBV = recentOBVValues[recentOBVValues.length - 1];
            const previousOBV = recentOBVValues[0];
            
            const obvChange = previousOBV !== 0 ? ((currentOBV - previousOBV) / Math.abs(previousOBV)) * 100 : 0;
            
            let trend = 'neutral';
            let trendStrength = 0;
            
            const lastFiveOBV = recentOBVValues.slice(-5);
            
            let risingCount = 0;
            let fallingCount = 0;
            
            for (let i = 1; i < lastFiveOBV.length; i++) {
                if (lastFiveOBV[i] > lastFiveOBV[i-1]) {
                    risingCount++;
                } else if (lastFiveOBV[i] < lastFiveOBV[i-1]) {
                    fallingCount++;
                }
            }
            
            if (risingCount >= 3 && currentOBV > previousOBV) {
                trend = 'rising';
                trendStrength = Math.abs(obvChange);
            } else if (fallingCount >= 3 && currentOBV < previousOBV) {
                trend = 'falling';
                trendStrength = Math.abs(obvChange);
            } else {
                trend = 'neutral';
                trendStrength = 0;
            }
            
            const recentPrices = klines.slice(-OBV_PERIOD).map(k => k.close);
            const priceChange = ((recentPrices[recentPrices.length - 1] - recentPrices[0]) / recentPrices[0]) * 100;
            
            const volumeConfirmation = 
                (trend === 'rising' && priceChange > 0) || 
                (trend === 'falling' && priceChange < 0) ||
                (trend === 'neutral' && Math.abs(priceChange) < 0.5);
            
            return {
                trend: trend,
                obvValue: parseFloat(currentOBV.toFixed(2)),
                obvChange: parseFloat(obvChange.toFixed(2)),
                trendStrength: parseFloat(trendStrength.toFixed(2)),
                volumeConfirmation: volumeConfirmation
            };
        }
        
        // Calculate Ichimoku Cloud position
        function calculateIchimokuCloud(klines, currentPrice) {
            if (klines.length < 52) {
                return {
                    cloudPosition: 'insufficient data',
                    conversionLine: 0,
                    baseLine: 0,
                    leadingSpanA: 0,
                    leadingSpanB: 0,
                    cloudTop: 0,
                    cloudBottom: 0,
                    priceVsCloud: 0
                };
            }
            
            const tenkanPeriod = 9;
            let tenkanHigh = 0;
            let tenkanLow = Number.MAX_VALUE;
            
            for (let i = klines.length - tenkanPeriod; i < klines.length; i++) {
                if (i >= 0) {
                    tenkanHigh = Math.max(tenkanHigh, klines[i].high);
                    tenkanLow = Math.min(tenkanLow, klines[i].low);
                }
            }
            
            const conversionLine = (tenkanHigh + tenkanLow) / 2;
            
            const kijunPeriod = 26;
            let kijunHigh = 0;
            let kijunLow = Number.MAX_VALUE;
            
            for (let i = klines.length - kijunPeriod; i < klines.length; i++) {
                if (i >= 0) {
                    kijunHigh = Math.max(kijunHigh, klines[i].high);
                    kijunLow = Math.min(kijunLow, klines[i].low);
                }
            }
            
            const baseLine = (kijunHigh + kijunLow) / 2;
            
            const leadingSpanA = (conversionLine + baseLine) / 2;
            
            const senkouBPeriod = 52;
            let senkouBHigh = 0;
            let senkouBLow = Number.MAX_VALUE;
            
            for (let i = klines.length - senkouBPeriod; i < klines.length; i++) {
                if (i >= 0) {
                    senkouBHigh = Math.max(senkouBHigh, klines[i].high);
                    senkouBLow = Math.min(senkouBLow, klines[i].low);
                }
            }
            
            const leadingSpanB = (senkouBHigh + senkouBLow) / 2;
            
            const cloudTop = Math.max(leadingSpanA, leadingSpanB);
            const cloudBottom = Math.min(leadingSpanA, leadingSpanB);
            
            let cloudPosition = 'inside';
            let priceVsCloud = 0;
            
            if (currentPrice > cloudTop) {
                cloudPosition = 'above';
                priceVsCloud = ((currentPrice - cloudTop) / cloudTop) * 100;
            } else if (currentPrice < cloudBottom) {
                cloudPosition = 'below';
                priceVsCloud = ((cloudBottom - currentPrice) / currentPrice) * 100;
            } else {
                cloudPosition = 'inside';
                const cloudThickness = cloudTop - cloudBottom;
                if (cloudThickness > 0) {
                    priceVsCloud = ((currentPrice - cloudBottom) / cloudThickness) * 100;
                }
            }
            
            return {
                cloudPosition: cloudPosition,
                conversionLine: parseFloat(conversionLine.toFixed(2)),
                baseLine: parseFloat(baseLine.toFixed(2)),
                leadingSpanA: parseFloat(leadingSpanA.toFixed(2)),
                leadingSpanB: parseFloat(leadingSpanB.toFixed(2)),
                cloudTop: parseFloat(cloudTop.toFixed(2)),
                cloudBottom: parseFloat(cloudBottom.toFixed(2)),
                priceVsCloud: parseFloat(priceVsCloud.toFixed(2))
            };
        }
        
        // Calculate Exponential Moving Average (EMA)
        function calculateEMA(data, period) {
            if (data.length < period) {
                return new Array(data.length).fill(null);
            }
            
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += data[i];
            }
            
            let emaValue = sum / period;
            ema.push(emaValue);
            
            for (let i = period; i < data.length; i++) {
                emaValue = (data[i] - emaValue) * multiplier + emaValue;
                ema.push(emaValue);
            }
            
            const result = new Array(period - 1).fill(null);
            return result.concat(ema);
        }
        
        // Update the table with current data
        function updateTable() {
            const loadingRow = tableBody.querySelector('.loading');
            if (loadingRow) {
                loadingRow.remove();
            }
            
            const existingRows = tableBody.querySelectorAll('tr[data-symbol]');
            existingRows.forEach(row => row.remove());
            
            let symbolsToDisplay = SYMBOLS;
            if (currentView === 'watchlist') {
                symbolsToDisplay = SYMBOLS.filter(symbol => watchlist.has(symbol));
                
                if (symbolsToDisplay.length === 0) {
                    tableBody.innerHTML = `
                        <tr class="loading">
                            <td colspan="24">
                                <div style="padding: 40px; text-align: center;">
                                    <i class="fas fa-star" style="font-size: 2rem; color: #ffc107; margin-bottom: 15px;"></i>
                                    <div>Your watchlist is empty</div>
                                    <div style="margin-top: 10px; font-size: 0.9rem; color: #8a9bb8;">
                                        Click the star icon <i class="far fa-star" style="color: #ffc107;"></i> next to any cryptocurrency to add it to your watchlist.
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                    return;
                }
            }
            
            symbolsToDisplay.forEach(symbol => {
                const data = cryptoData[symbol];
                if (!data) return;
                
                const row = document.createElement('tr');
                row.setAttribute('data-symbol', symbol);
                tableBody.appendChild(row);
                
                const isInWatchlist = watchlist.has(symbol);
                const starIcon = isInWatchlist ? '<i class="fas fa-star"></i>' : '<i class="far fa-star"></i>';
                const starClass = isInWatchlist ? 'watchlist-star active' : 'watchlist-star';
                
                row.innerHTML = `
                    <td>
                        <div class="crypto-name">
                            <div class="${starClass}" data-symbol="${symbol}">
                                ${starIcon}
                            </div>
                            <div class="crypto-icon ${symbol.substring(0, 3).toLowerCase()}">
                                ${symbol.substring(0, 1)}
                            </div>
                            <div>
                                <div>
                                    <a href="#" class="crypto-link" id="link-${symbol}">
                                        <i class="fas fa-external-link-alt"></i>${symbol}
                                    </a>
                                </div>
                                <div class="price-change" id="change-${symbol}">--</div>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="price" id="price-${symbol}">$${formatNumber(data.currentPrice)}</div>
                    </td>
                    <td>
                        <div class="swing-pattern-container" id="pattern-${symbol}">
                            <span class="pattern-badge consolidation">Analyzing...</span>
                            <div class="swing-details">Loading swing data...</div>
                        </div>
                    </td>
                    <td>
                        <div class="macd-indicator" id="macd-${symbol}">
                            <span class="macd-badge macd-neutral">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="crossover-indicator" id="crossover-${symbol}">
                            <span class="crossover-badge no-crossover">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="volume-indicator" id="volume-${symbol}">
                            <span class="volume-badge volume-normal">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="atr-indicator" id="atr-${symbol}">
                            <span class="atr-badge atr-low">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="obv-indicator" id="obv-${symbol}">
                            <span class="obv-badge obv-neutral">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="ichimoku-indicator" id="ichimoku-${symbol}">
                            <span class="ichimoku-badge ichimoku-inside">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="ema-indicator" id="ema-${symbol}">
                            <span class="ema-badge ema-cross">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="correlation-indicator" id="correlation-${symbol}">
                            <span class="correlation-badge correlation-low">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="support-levels-indicator" id="support-levels-${symbol}">
                            <span class="support-levels-badge support-levels-none">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="flipped-support-indicator" id="flipped-support-${symbol}">
                            <span class="flipped-support-badge flipped-support-none">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="liquidity-grab-support-indicator" id="liquidity-grab-support-${symbol}">
                            <span class="liquidity-grab-support-badge liquidity-grab-support-no">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="resistance-levels-indicator" id="resistance-levels-${symbol}">
                            <span class="resistance-levels-badge resistance-levels-none">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="flipped-resistance-indicator" id="flipped-resistance-${symbol}">
                            <span class="flipped-resistance-badge flipped-resistance-none">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="liquidity-grab-resistance-indicator" id="liquidity-grab-resistance-${symbol}">
                            <span class="liquidity-grab-resistance-badge liquidity-grab-resistance-no">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="cpr-indicator" id="cpr-${symbol}">
                            <span class="cpr-badge cpr-inside">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="support-convergence-indicator" id="support-convergence-${symbol}">
                            <span class="support-convergence-badge support-convergence-no">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="resistance-convergence-indicator" id="resistance-convergence-${symbol}">
                            <span class="resistance-convergence-badge resistance-convergence-no">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="vwap-indicator" id="vwap-${symbol}">
                            <span class="vwap-badge vwap-near">Analyzing...</span>
                        </div>
                    </td>
                    <td>
                        <div class="indicator-summary-container" id="indicator-summary1-${symbol}">
                            <div class="indicator-summary-item">
                                <span class="indicator-summary-label">MACD:</span>
                                <span class="indicator-summary-value">Analyzing...</span>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="indicator-summary-container" id="indicator-summary2-${symbol}">
                            <div class="indicator-summary-item">
                                <span class="indicator-summary-label">Volume:</span>
                                <span class="indicator-summary-value">Analyzing...</span>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="indicator-summary-container" id="indicator-summary3-${symbol}">
                            <div class="indicator-summary-item">
                                <span class="indicator-summary-label">CPR-TC:</span>
                                <span class="indicator-summary-value">Analyzing...</span>
                            </div>
                        </div>
                    </td>
                `;
                
                updatePriceCell(symbol, data.currentPrice, data.priceChange || 0);
                updateSwingPatternCell(symbol, data.swingPattern, data.currentPrice);
                updateMACDCell(symbol, data.macdAnalysis);
                updateCrossoverCell(symbol, data.macdAnalysis);
                updateVolumeCell(symbol, data.volumeSpike);
                updateATRCell(symbol, data.atrAnalysis, data.currentPrice);
                updateOBVCell(symbol, data.obvAnalysis);
                updateIchimokuCell(symbol, data.ichimokuAnalysis, data.currentPrice);
                updateEMACell(symbol, data.emaAnalysis, data.currentPrice);
                updateCorrelationCell(symbol, data.correlationWithBTC || {
                    correlation: 0,
                    percentage: 0,
                    strength: 'unknown',
                    independence: 100,
                    trend: 'unknown'
                });
                updateSupportLevelsCell(symbol, data.supportLevels || [], data.currentPrice);
                updateFlippedSupportCell(symbol, data.flippedLevels || [], data.currentPrice);
                updateLiquidityGrabSupportCell(symbol, data.liquidityGrabSupport || {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Calculating...'
                }, data.currentPrice);
                updateResistanceLevelsCell(symbol, data.resistanceLevels || [], data.currentPrice);
                updateFlippedResistanceCell(symbol, data.flippedResistanceLevels || [], data.currentPrice);
                updateLiquidityGrabResistanceCell(symbol, data.liquidityGrabResistance || {
                    detected: false,
                    level: null,
                    price: 0,
                    details: 'Calculating...'
                }, data.currentPrice);
                updateCPRCell(symbol, data.cprAnalysis || {
                    tc: 0,
                    cp: 0,
                    bc: 0,
                    position: 'error',
                    priceVsCPR: 0,
                    range: 0
                }, data.currentPrice);
                updateSupportConvergenceCell(symbol, data.supportConvergence || {
                    status: 'No Convergence',
                    price: null,
                    supportType: '',
                    cprType: '',
                    differencePercent: 0,
                    supportPrice: null
                });
                updateResistanceConvergenceCell(symbol, data.resistanceConvergence || {
                    status: 'No Convergence',
                    price: null,
                    resistanceType: '',
                    cprType: '',
                    differencePercent: 0,
                    resistancePrice: null
                });
                updateVWAPCell(symbol, data.vwapAnalysis || {
                    vwap: 0,
                    upperBand: 0,
                    lowerBand: 0,
                    distanceFromVWAP: 0,
                    distanceFromUpperBand: 0,
                    distanceFromLowerBand: 0,
                    position: 'error',
                    standardDeviation: 0,
                    candlesUsed: 0
                }, data.currentPrice);
                updateIndicatorSummary1Cell(symbol, data.indicatorSummary || calculateIndicatorSummary(data, data.currentPrice));
                updateIndicatorSummary2Cell(symbol, data.indicatorSummary || calculateIndicatorSummary(data, data.currentPrice));
                updateIndicatorSummary3Cell(symbol, data.indicatorSummary || calculateIndicatorSummary(data, data.currentPrice));
            });
        }
        
        // Update price cell with animation
        function updatePriceCell(symbol, price, change) {
            const priceElement = document.getElementById(`price-${symbol}`);
            const changeElement = document.getElementById(`change-${symbol}`);
            
            if (!priceElement) return;
            
            let directionClass = 'neutral';
            let changeText = '';
            
            if (change > 0) {
                directionClass = 'up';
                const prevPrice = price - change;
                changeText = `+${formatNumber(change)} (${prevPrice > 0 ? ((change / prevPrice) * 100).toFixed(2) : '0.00'}%)`;
            } else if (change < 0) {
                directionClass = 'down';
                const prevPrice = price - change;
                changeText = `${formatNumber(change)} (${prevPrice > 0 ? ((change / prevPrice) * 100).toFixed(2) : '0.00'}%)`;
            }
            
            if (changeElement) {
                changeElement.textContent = changeText;
                changeElement.className = `price-change ${directionClass}`;
            }
            
            priceElement.classList.remove('up', 'down', 'neutral');
            priceElement.classList.add(directionClass);
            
            priceElement.style.opacity = '0.7';
            setTimeout(() => {
                priceElement.textContent = `$${formatNumber(price)}`;
                priceElement.style.opacity = '1';
            }, 150);
        }
        
        // Update swing pattern cell
        function updateSwingPatternCell(symbol, patternData, currentPrice) {
            const patternElement = document.getElementById(`pattern-${symbol}`);
            if (!patternElement) return;
            
            let badgeClass = 'consolidation';
            let patternText = 'Consolidation';
            let detailsHtml = '';
            
            switch (patternData.pattern) {
                case 'higher-high':
                    badgeClass = 'higher-high';
                    patternText = 'Higher High';
                    detailsHtml = `
                        Current: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                        Breached swing high: <span class="swing-price">$${formatNumber(patternData.breachedSwingPrice)}</span><br>
                        <span class="percentage">+${patternData.percentage}% above breached swing high</span>
                    `;
                    break;
                case 'lower-low':
                    badgeClass = 'lower-low';
                    patternText = 'Lower Low';
                    detailsHtml = `
                        Current: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                        Breached swing low: <span class="swing-price">$${formatNumber(patternData.breachedSwingPrice)}</span><br>
                        <span class="percentage">-${patternData.percentage}% below breached swing low</span>
                    `;
                    break;
                case 'consolidation':
                    badgeClass = 'consolidation';
                    patternText = 'Consolidation';
                    detailsHtml = `
                        Current: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                        No recent swing levels breached<br>
                        Trading within recent range
                    `;
                    break;
                default:
                    badgeClass = 'consolidation';
                    patternText = 'Analyzing...';
                    detailsHtml = 'Calculating swing pattern...';
            }
            
            patternElement.innerHTML = `
                <span class="pattern-badge ${badgeClass}">${patternText}</span>
                <div class="swing-details">${detailsHtml}</div>
            `;
        }
        
        // Update MACD cell
        function updateMACDCell(symbol, macdData) {
            const macdElement = document.getElementById(`macd-${symbol}`);
            if (!macdElement) return;
            
            let badgeClass = 'macd-neutral';
            let badgeText = 'Analyzing...';
            let detailsHtml = '';
            
            switch (macdData.status) {
                case 'positive':
                    badgeClass = 'macd-positive';
                    badgeText = 'Positive';
                    detailsHtml = `
                        <div class="macd-details">
                            MACD: <span class="swing-price">${formatNumber(macdData.macdLine)}</span><br>
                            Signal: <span class="swing-price">${formatNumber(macdData.signalLine)}</span><br>
                            Histogram: <span class="percentage">${formatNumber(macdData.histogram)}</span>
                        </div>
                    `;
                    break;
                case 'negative':
                    badgeClass = 'macd-negative';
                    badgeText = 'Negative';
                    detailsHtml = `
                        <div class="macd-details">
                            MACD: <span class="swing-price">${formatNumber(macdData.macdLine)}</span><br>
                            Signal: <span class="swing-price">${formatNumber(macdData.signalLine)}</span><br>
                            Histogram: <span class="percentage">${formatNumber(macdData.histogram)}</span>
                        </div>
                    `;
                    break;
                case 'neutral':
                    badgeClass = 'macd-neutral';
                    badgeText = 'Neutral';
                    detailsHtml = `
                        <div class="macd-details">
                            MACD: <span class="swing-price">${formatNumber(macdData.macdLine)}</span><br>
                            Signal: <span class="swing-price">${formatNumber(macdData.signalLine)}</span><br>
                            Histogram: <span class="percentage">${formatNumber(macdData.histogram)}</span>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'macd-neutral';
                    badgeText = 'Error';
                    detailsHtml = '<div class="macd-details">Error calculating MACD</div>';
            }
            
            macdElement.innerHTML = `
                <span class="macd-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update MACD Crossover cell
        function updateCrossoverCell(symbol, macdData) {
            const crossoverElement = document.getElementById(`crossover-${symbol}`);
            if (!crossoverElement) return;
            
            let badgeClass = 'no-crossover';
            let badgeText = 'None';
            let detailsHtml = '';
            
            switch (macdData.crossover) {
                case 'bullish':
                    badgeClass = 'bullish-crossover';
                    badgeText = 'Bullish Crossover';
                    detailsHtml = `
                        <div class="crossover-details">
                            Recent bullish crossover detected<br>
                            Strength: <span class="percentage">${formatNumber(macdData.crossoverStrength)}</span><br>
                            ${macdData.crossoverPeriodsAgo === 0 ? 'Just occurred' : `${macdData.crossoverPeriodsAgo} period${macdData.crossoverPeriodsAgo > 1 ? 's' : ''} ago`}
                        </div>
                    `;
                    break;
                case 'bearish':
                    badgeClass = 'bearish-crossover';
                    badgeText = 'Bearish Crossover';
                    detailsHtml = `
                        <div class="crossover-details">
                            Recent bearish crossover detected<br>
                            Strength: <span class="percentage">${formatNumber(macdData.crossoverStrength)}</span><br>
                            ${macdData.crossoverPeriodsAgo === 0 ? 'Just occurred' : `${macdData.crossoverPeriodsAgo} period${macdData.crossoverPeriodsAgo > 1 ? 's' : ''} ago`}
                        </div>
                    `;
                    break;
                case 'none':
                    badgeClass = 'no-crossover';
                    badgeText = 'None';
                    detailsHtml = `
                        <div class="crossover-details">
                            No recent crossover detected<br>
                            MACD status: <span class="${macdData.status === 'positive' ? 'percentage' : ''}">${macdData.status}</span>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'no-crossover';
                    badgeText = 'Error';
                    detailsHtml = '<div class="crossover-details">Error detecting crossover</div>';
            }
            
            crossoverElement.innerHTML = `
                <span class="crossover-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update Volume Spike cell
        function updateVolumeCell(symbol, volumeData) {
            const volumeElement = document.getElementById(`volume-${symbol}`);
            if (!volumeElement) return;
            
            let badgeClass = 'volume-normal';
            let badgeText = 'Normal';
            let detailsHtml = '';
            
            if (volumeData.spike) {
                badgeClass = 'volume-spike';
                badgeText = `${volumeData.multiple}x Spike`;
                detailsHtml = `
                    <div class="volume-details">
                        Volume: <span class="swing-price">${formatLargeNumber(volumeData.volume)}</span><br>
                        Average (20 candles): <span class="swing-price">${formatLargeNumber(volumeData.averageVolume)}</span><br>
                        <span class="percentage">${volumeData.multiple}x above average</span>
                    </div>
                `;
            } else {
                badgeClass = 'volume-normal';
                badgeText = 'Normal';
                detailsHtml = `
                    <div class="volume-details">
                        Volume: <span class="swing-price">${formatLargeNumber(volumeData.volume)}</span><br>
                        Average (20 candles): <span class="swing-price">${formatLargeNumber(volumeData.averageVolume)}</span><br>
                        ${volumeData.multiple > 0 ? `${volumeData.multiple}x of average` : 'Calculating...'}
                    </div>
                `;
            }
            
            volumeElement.innerHTML = `
                <span class="volume-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update ATR Volatility cell
        function updateATRCell(symbol, atrData, currentPrice) {
            const atrElement = document.getElementById(`atr-${symbol}`);
            if (!atrElement) return;
            
            let badgeClass = 'atr-low';
            let badgeText = 'Low';
            let detailsHtml = '';
            
            switch (atrData.volatility) {
                case 'high':
                    badgeClass = 'atr-high';
                    badgeText = 'High';
                    detailsHtml = `
                        <div class="atr-details">
                            ATR: <span class="swing-price">${formatNumber(atrData.atrValue)}</span><br>
                            ATR %: <span class="percentage">${atrData.atrPercentage}%</span><br>
                            24h Change: <span class="${atrData.priceChange24h >= 0 ? 'percentage' : ''}">${atrData.priceChange24h >= 0 ? '+' : ''}${atrData.priceChange24h}%</span><br>
                            <em>Very high volatility</em>
                        </div>
                    `;
                    break;
                case 'moderate':
                    badgeClass = 'atr-moderate';
                    badgeText = 'Moderate';
                    detailsHtml = `
                        <div class="atr-details">
                            ATR: <span class="swing-price">${formatNumber(atrData.atrValue)}</span><br>
                            ATR %: <span class="percentage">${atrData.atrPercentage}%</span><br>
                            24h Change: <span class="${atrData.priceChange24h >= 0 ? 'percentage' : ''}">${atrData.priceChange24h >= 0 ? '+' : ''}${atrData.priceChange24h}%</span><br>
                            <em>Higher volatility</em>
                        </div>
                    `;
                    break;
                case 'good':
                    badgeClass = 'atr-good';
                    badgeText = 'Good';
                    detailsHtml = `
                        <div class="atr-details">
                            ATR: <span class="swing-price">${formatNumber(atrData.atrValue)}</span><br>
                            ATR %: <span class="percentage">${atrData.atrPercentage}%</span><br>
                            24h Change: <span class="${atrData.priceChange24h >= 0 ? 'percentage' : ''}">${atrData.priceChange24h >= 0 ? '+' : ''}${atrData.priceChange24h}%</span><br>
                            <em>Ideal volatility</em>
                        </div>
                    `;
                    break;
                case 'low':
                    badgeClass = 'atr-low';
                    badgeText = 'Low';
                    detailsHtml = `
                        <div class="atr-details">
                            ATR: <span class="swing-price">${formatNumber(atrData.atrValue)}</span><br>
                            ATR %: <span class="percentage">${atrData.atrPercentage}%</span><br>
                            24h Change: <span class="${atrData.priceChange24h >= 0 ? 'percentage' : ''}">${atrData.priceChange24h >= 0 ? '+' : ''}${atrData.priceChange24h}%</span><br>
                            <em>Low volatility</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'atr-low';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="atr-details">Calculating ATR volatility...</div>';
            }
            
            atrElement.innerHTML = `
                <span class="atr-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update OBV cell
        function updateOBVCell(symbol, obvData) {
            const obvElement = document.getElementById(`obv-${symbol}`);
            if (!obvElement) return;
            
            let badgeClass = 'obv-neutral';
            let badgeText = 'None';
            let detailsHtml = '';
            
            switch (obvData.trend) {
                case 'rising':
                    badgeClass = 'obv-rising';
                    badgeText = 'Rising Volume';
                    detailsHtml = `
                        <div class="obv-details">
                            OBV: <span class="swing-price">${formatLargeNumber(obvData.obvValue)}</span><br>
                            Change: <span class="percentage">+${obvData.obvChange}%</span><br>
                            Strength: <span class="swing-price">${obvData.trendStrength.toFixed(2)}</span><br>
                            ${obvData.volumeConfirmation ? ' Confirmed with price' : ' No price confirmation'}
                        </div>
                    `;
                    break;
                case 'falling':
                    badgeClass = 'obv-falling';
                    badgeText = 'Declining Volume';
                    detailsHtml = `
                        <div class="obv-details">
                            OBV: <span class="swing-price">${formatLargeNumber(obvData.obvValue)}</span><br>
                            Change: <span class="percentage">${obvData.obvChange}%</span><br>
                            Strength: <span class="swing-price">${obvData.trendStrength.toFixed(2)}</span><br>
                            ${obvData.volumeConfirmation ? ' Confirmed with price' : ' No price confirmation'}
                        </div>
                    `;
                    break;
                case 'neutral':
                    badgeClass = 'obv-neutral';
                    badgeText = 'None';
                    detailsHtml = `
                        <div class="obv-details">
                            OBV: <span class="swing-price">${formatLargeNumber(obvData.obvValue)}</span><br>
                            Change: <span class="percentage">${obvData.obvChange >= 0 ? '+' : ''}${obvData.obvChange}%</span><br>
                            Volume flow is balanced<br>
                            No clear accumulation or distribution
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'obv-neutral';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="obv-details">Calculating OBV...</div>';
            }
            
            obvElement.innerHTML = `
                <span class="obv-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update Ichimoku Cloud cell
        function updateIchimokuCell(symbol, ichimokuData, currentPrice) {
            const ichimokuElement = document.getElementById(`ichimoku-${symbol}`);
            if (!ichimokuElement) return;
            
            let badgeClass = 'ichimoku-inside';
            let badgeText = 'Inside';
            let detailsHtml = '';
            
            switch (ichimokuData.cloudPosition) {
                case 'above':
                    badgeClass = 'ichimoku-above';
                    badgeText = 'Above Cloud';
                    detailsHtml = `
                        <div class="ichimoku-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            Cloud Top: <span class="swing-price">$${formatNumber(ichimokuData.cloudTop)}</span><br>
                            Cloud Bottom: <span class="swing-price">$${formatNumber(ichimokuData.cloudBottom)}</span><br>
                            <span class="percentage">+${ichimokuData.priceVsCloud}% above cloud</span><br>
                            <em>Bullish signal</em>
                        </div>
                    `;
                    break;
                case 'below':
                    badgeClass = 'ichimoku-below';
                    badgeText = 'Below Cloud';
                    detailsHtml = `
                        <div class="ichimoku-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            Cloud Top: <span class="swing-price">$${formatNumber(ichimokuData.cloudTop)}</span><br>
                            Cloud Bottom: <span class="swing-price">$${formatNumber(ichimokuData.cloudBottom)}</span><br>
                            <span class="percentage">${ichimokuData.priceVsCloud}% below cloud</span><br>
                            <em>Bearish signal</em>
                        </div>
                    `;
                    break;
                case 'inside':
                    badgeClass = 'ichimoku-inside';
                    badgeText = 'Inside Cloud';
                    detailsHtml = `
                        <div class="ichimoku-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            Cloud Top: <span class="swing-price">$${formatNumber(ichimokuData.cloudTop)}</span><br>
                            Cloud Bottom: <span class="swing-price">$${formatNumber(ichimokuData.cloudBottom)}</span><br>
                            ${ichimokuData.priceVsCloud > 0 ? `<span class="percentage">${ichimokuData.priceVsCloud}% inside cloud</span><br>` : ''}
                            <em>Neutral/Consolidation</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'ichimoku-inside';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="ichimoku-details">Calculating Ichimoku Cloud...</div>';
            }
            
            ichimokuElement.innerHTML = `
                <span class="ichimoku-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update EMA cell
        function updateEMACell(symbol, emaData, currentPrice) {
            const emaElement = document.getElementById(`ema-${symbol}`);
            if (!emaElement) return;
            
            let badgeClass = 'ema-cross';
            let badgeText = 'Near EMA';
            let detailsHtml = '';
            
            switch (emaData.position) {
                case 'above':
                    badgeClass = 'ema-above';
                    badgeText = 'Above EMA';
                    detailsHtml = `
                        <div class="ema-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            EMA(${currentEMAPeriod}): <span class="swing-price">$${formatNumber(emaData.emaValue)}</span><br>
                            Difference: <span class="percentage">+${emaData.differencePercentage}%</span><br>
                            EMA Trend: <span class="${emaData.trend === 'rising' ? 'percentage' : ''}">${emaData.trend}</span><br>
                            <em>Bullish signal</em>
                        </div>
                    `;
                    break;
                case 'below':
                    badgeClass = 'ema-below';
                    badgeText = 'Below EMA';
                    detailsHtml = `
                        <div class="ema-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            EMA(${currentEMAPeriod}): <span class="swing-price">$${formatNumber(emaData.emaValue)}</span><br>
                            Difference: <span class="percentage">${emaData.differencePercentage}%</span><br>
                            EMA Trend: <span class="${emaData.trend === 'rising' ? 'percentage' : ''}">${emaData.trend}</span><br>
                            <em>Bearish signal</em>
                        </div>
                    `;
                    break;
                case 'cross':
                    badgeClass = 'ema-cross';
                    badgeText = 'Near EMA';
                    detailsHtml = `
                        <div class="ema-details">
                            Price: <span class="swing-price">$${formatNumber(currentPrice)}</span><br>
                            EMA(${currentEMAPeriod}): <span class="swing-price">$${formatNumber(emaData.emaValue)}</span><br>
                            Difference: <span class="percentage">${emaData.differencePercentage >= 0 ? '+' : ''}${emaData.differencePercentage}%</span><br>
                            EMA Trend: <span class="${emaData.trend === 'rising' ? 'percentage' : ''}">${emaData.trend}</span><br>
                            <em>Potential crossover zone</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'ema-cross';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="ema-details">Calculating EMA...</div>';
            }
            
            emaElement.innerHTML = `
                <span class="ema-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update correlation with BTC cell
        function updateCorrelationCell(symbol, correlationData) {
            const correlationElement = document.getElementById(`correlation-${symbol}`);
            if (!correlationElement) return;
            
            let badgeClass = 'correlation-low';
            let badgeText = 'Low';
            let detailsHtml = '';
            let progressBarClass = 'low';
            
            switch (correlationData.strength) {
                case 'high':
                    badgeClass = 'correlation-high';
                    badgeText = `High (${correlationData.percentage}%)`;
                    progressBarClass = 'high';
                    detailsHtml = `
                        <div class="correlation-details">
                            Correlation: <span class="swing-price">${correlationData.correlation >= 0 ? '+' : ''}${correlationData.correlation}</span><br>
                            Independence: <span class="percentage">${correlationData.independence}%</span><br>
                            Trend: <span class="${correlationData.correlation > 0 ? 'percentage' : ''}">${correlationData.trend}</span><br>
                            <div class="progress-bar-container">
                                <div class="progress-bar ${progressBarClass}" style="width: ${correlationData.percentage}%"></div>
                            </div>
                            <em>High correlation with BTC</em>
                        </div>
                    `;
                    break;
                case 'medium':
                    badgeClass = 'correlation-medium';
                    badgeText = `Medium (${correlationData.percentage}%)`;
                    progressBarClass = 'medium';
                    detailsHtml = `
                        <div class="correlation-details">
                            Correlation: <span class="swing-price">${correlationData.correlation >= 0 ? '+' : ''}${correlationData.correlation}</span><br>
                            Independence: <span class="percentage">${correlationData.independence}%</span><br>
                            Trend: <span class="${correlationData.correlation > 0 ? 'percentage' : ''}">${correlationData.trend}</span><br>
                            <div class="progress-bar-container">
                                <div class="progress-bar ${progressBarClass}" style="width: ${correlationData.percentage}%"></div>
                            </div>
                            <em>Moderate correlation with BTC</em>
                        </div>
                    `;
                    break;
                case 'low':
                    badgeClass = 'correlation-low';
                    badgeText = `Low (${correlationData.percentage}%)`;
                    progressBarClass = 'low';
                    detailsHtml = `
                        <div class="correlation-details">
                            Correlation: <span class="swing-price">${correlationData.correlation >= 0 ? '+' : ''}${correlationData.correlation}</span><br>
                            Independence: <span class="percentage">${correlationData.independence}%</span><br>
                            Trend: <span class="${correlationData.correlation > 0 ? 'percentage' : ''}">${correlationData.trend}</span><br>
                            <div class="progress-bar-container">
                                <div class="progress-bar ${progressBarClass}" style="width: ${correlationData.percentage}%"></div>
                            </div>
                            <em>Low correlation with BTC (more independent)</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'correlation-low';
                    badgeText = 'Calculating...';
                    detailsHtml = '<div class="correlation-details">Calculating correlation with BTC...</div>';
            }
            
            correlationElement.innerHTML = `
                <span class="correlation-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update support levels cell
        function updateSupportLevelsCell(symbol, supportLevels, currentPrice) {
            const supportElement = document.getElementById(`support-levels-${symbol}`);
            if (!supportElement) return;
            
            let badgeClass = 'support-levels-none';
            let badgeText = 'None';
            let detailsHtml = '';
            
            if (supportLevels && supportLevels.length > 0) {
                badgeClass = 'support-levels-active';
                badgeText = `${supportLevels.length} Support Levels`;
                
                detailsHtml = '<div class="support-levels-details">';
                supportLevels.forEach((level, index) => {
                    const percent = formatPercentForLevels(level.price, currentPrice);
                    detailsHtml += `
                        <div class="level-item support-level">
                            <div>
                                <div class="level-price">$${formatPriceForLevels(level.price)}</div>
                                <div>${level.type}</div>
                            </div>
                            <div class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                                ${percent.isPositive ? '+' : ''}${percent.value}%
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            } else {
                badgeClass = 'support-levels-none';
                badgeText = 'No Support';
                detailsHtml = '<div class="support-levels-details">No support levels detected (LL/HL)</div>';
            }
            
            supportElement.innerHTML = `
                <span class="support-levels-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update flipped support cell
        function updateFlippedSupportCell(symbol, flippedLevels, currentPrice) {
            const flippedElement = document.getElementById(`flipped-support-${symbol}`);
            if (!flippedElement) return;
            
            let badgeClass = 'flipped-support-none';
            let badgeText = 'None';
            let detailsHtml = '';
            
            if (flippedLevels && flippedLevels.length > 0) {
                badgeClass = 'flipped-support-active';
                badgeText = `${flippedLevels.length} Flipped Supports`;
                
                detailsHtml = '<div class="flipped-support-details">';
                flippedLevels.forEach((level, index) => {
                    const percent = formatPercentForLevels(level.price, currentPrice);
                    detailsHtml += `
                        <div class="level-item flipped-level">
                            <div>
                                <div class="level-price">$${formatPriceForLevels(level.price)}</div>
                                <div>${level.type} (Breached)</div>
                            </div>
                            <div class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                                ${percent.isPositive ? '+' : ''}${percent.value}%
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            } else {
                badgeClass = 'flipped-support-none';
                badgeText = 'No Flipped Support';
                detailsHtml = '<div class="flipped-support-details">No flipped support levels detected (Breached HH/LH)</div>';
            }
            
            flippedElement.innerHTML = `
                <span class="flipped-support-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update liquidity grab support cell
        function updateLiquidityGrabSupportCell(symbol, liquidityGrabData, currentPrice) {
            const liquidityElement = document.getElementById(`liquidity-grab-support-${symbol}`);
            if (!liquidityElement) return;
            
            let badgeClass = 'liquidity-grab-support-no';
            let badgeText = 'No';
            let detailsHtml = '';
            
            if (liquidityGrabData.detected && liquidityGrabData.level) {
                badgeClass = 'liquidity-grab-support-yes';
                badgeText = `Yes ($${formatNumber(liquidityGrabData.price)})`;
                
                const percent = formatPercentForLevels(liquidityGrabData.price, currentPrice);
                detailsHtml = `
                    <div class="liquidity-grab-support-details">
                        <strong>Liquidity Grab Detected!</strong><br>
                        Support Level: <span class="swing-price">$${formatNumber(liquidityGrabData.price)}</span><br>
                        Type: <span class="swing-price">${liquidityGrabData.level.type}</span><br>
                        Distance: <span class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                            ${percent.isPositive ? '+' : ''}${percent.value}%
                        </span><br>
                        <em>${liquidityGrabData.details}</em>
                    </div>
                `;
            } else {
                badgeClass = 'liquidity-grab-support-no';
                badgeText = 'No';
                detailsHtml = `
                    <div class="liquidity-grab-support-details">
                        No liquidity grab detected for support levels.<br>
                        <em>Support levels were not breached and reclaimed</em>
                    </div>
                `;
            }
            
            liquidityElement.innerHTML = `
                <span class="liquidity-grab-support-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update resistance levels cell
        function updateResistanceLevelsCell(symbol, resistanceLevels, currentPrice) {
            const resistanceElement = document.getElementById(`resistance-levels-${symbol}`);
            if (!resistanceElement) return;
            
            let badgeClass = 'resistance-levels-none';
            let badgeText = 'None';
            let detailsHtml = '';
            
            if (resistanceLevels && resistanceLevels.length > 0) {
                badgeClass = 'resistance-levels-active';
                badgeText = `${resistanceLevels.length} Resistance Levels`;
                
                detailsHtml = '<div class="resistance-levels-details">';
                resistanceLevels.forEach((level, index) => {
                    const percent = formatPercentForLevels(level.price, currentPrice);
                    detailsHtml += `
                        <div class="level-item resistance-level">
                            <div>
                                <div class="level-price">$${formatPriceForLevels(level.price)}</div>
                                <div>${level.type}</div>
                            </div>
                            <div class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                                ${percent.isPositive ? '+' : ''}${percent.value}%
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            } else {
                badgeClass = 'resistance-levels-none';
                badgeText = 'No Resistance';
                detailsHtml = '<div class="resistance-levels-details">No resistance levels detected (HH/LH)</div>';
            }
            
            resistanceElement.innerHTML = `
                <span class="resistance-levels-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update flipped resistance cell
        function updateFlippedResistanceCell(symbol, flippedResistanceLevels, currentPrice) {
            const flippedElement = document.getElementById(`flipped-resistance-${symbol}`);
            if (!flippedElement) return;
            
            let badgeClass = 'flipped-resistance-none';
            let badgeText = 'None';
            let detailsHtml = '';
            
            if (flippedResistanceLevels && flippedResistanceLevels.length > 0) {
                badgeClass = 'flipped-resistance-active';
                badgeText = `${flippedResistanceLevels.length} Flipped Resistance`;
                
                detailsHtml = '<div class="flipped-resistance-details">';
                flippedResistanceLevels.forEach((level, index) => {
                    const percent = formatPercentForLevels(level.price, currentPrice);
                    detailsHtml += `
                        <div class="level-item flipped-resistance-level">
                            <div>
                                <div class="level-price">$${formatPriceForLevels(level.price)}</div>
                                <div>${level.type} (Breached)</div>
                            </div>
                            <div class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                                ${percent.isPositive ? '+' : ''}${percent.value}%
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            } else {
                badgeClass = 'flipped-resistance-none';
                badgeText = 'No Flipped Resistance';
                detailsHtml = '<div class="flipped-resistance-details">No flipped resistance levels detected (Breached LL/HL)</div>';
            }
            
            flippedElement.innerHTML = `
                <span class="flipped-resistance-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update liquidity grab resistance cell
        function updateLiquidityGrabResistanceCell(symbol, liquidityGrabData, currentPrice) {
            const liquidityElement = document.getElementById(`liquidity-grab-resistance-${symbol}`);
            if (!liquidityElement) return;
            
            let badgeClass = 'liquidity-grab-resistance-no';
            let badgeText = 'No';
            let detailsHtml = '';
            
            if (liquidityGrabData.detected && liquidityGrabData.level) {
                badgeClass = 'liquidity-grab-resistance-yes';
                badgeText = `Yes ($${formatNumber(liquidityGrabData.price)})`;
                
                const percent = formatPercentForLevels(liquidityGrabData.price, currentPrice);
                detailsHtml = `
                    <div class="liquidity-grab-resistance-details">
                        <strong>Liquidity Grab Detected!</strong><br>
                        Resistance Level: <span class="swing-price">$${formatNumber(liquidityGrabData.price)}</span><br>
                        Type: <span class="swing-price">${liquidityGrabData.level.type}</span><br>
                        Distance: <span class="level-percent ${percent.isPositive ? 'percent-positive' : 'percent-negative'}">
                            ${percent.isPositive ? '+' : ''}${percent.value}%
                        </span><br>
                        <em>${liquidityGrabData.details}</em>
                    </div>
                `;
            } else {
                badgeClass = 'liquidity-grab-resistance-no';
                badgeText = 'No';
                detailsHtml = `
                    <div class="liquidity-grab-resistance-details">
                        No liquidity grab detected for resistance levels.<br>
                        <em>Resistance levels were not breached and reclaimed</em>
                    </div>
                `;
            }
            
            liquidityElement.innerHTML = `
                <span class="liquidity-grab-resistance-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update CPR cell
        function updateCPRCell(symbol, cprData, currentPrice) {
            const cprElement = document.getElementById(`cpr-${symbol}`);
            if (!cprElement) return;
            
            let badgeClass = 'cpr-inside';
            let badgeText = 'Inside CPR';
            let detailsHtml = '';
            
            switch (cprData.position) {
                case 'above':
                    badgeClass = 'cpr-above';
                    badgeText = 'Above CPR';
                    detailsHtml = `
                        <div class="cpr-details">
                            <div class="cpr-level-item cpr-tc">
                                <div>TC: <span class="level-price">$${formatNumber(cprData.tc)}</span></div>
                                <div class="level-percent percent-negative">-${((cprData.tc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-cp">
                                <div>CP: <span class="level-price">$${formatNumber(cprData.cp)}</span></div>
                                <div class="level-percent percent-negative">-${((cprData.cp - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-bc">
                                <div>BC: <span class="level-price">$${formatNumber(cprData.bc)}</span></div>
                                <div class="level-percent percent-negative">-${((cprData.bc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${cprData.priceVsCPR}% above TC)</em>
                        </div>
                    `;
                    break;
                case 'below':
                    badgeClass = 'cpr-below';
                    badgeText = 'Below CPR';
                    detailsHtml = `
                        <div class="cpr-details">
                            <div class="cpr-level-item cpr-tc">
                                <div>TC: <span class="level-price">$${formatNumber(cprData.tc)}</span></div>
                                <div class="level-percent percent-positive">+${((cprData.tc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-cp">
                                <div>CP: <span class="level-price">$${formatNumber(cprData.cp)}</span></div>
                                <div class="level-percent percent-positive">+${((cprData.cp - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-bc">
                                <div>BC: <span class="level-price">$${formatNumber(cprData.bc)}</span></div>
                                <div class="level-percent percent-positive">+${((cprData.bc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${cprData.priceVsCPR}% below BC)</em>
                        </div>
                    `;
                    break;
                case 'inside':
                    badgeClass = 'cpr-inside';
                    badgeText = 'Inside CPR';
                    detailsHtml = `
                        <div class="cpr-details">
                            <div class="cpr-level-item cpr-tc">
                                <div>TC: <span class="level-price">$${formatNumber(cprData.tc)}</span></div>
                                <div class="level-percent percent-negative">-${((cprData.tc - currentPrice) / currentPrice * 100).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-cp">
                                <div>CP: <span class="level-price">$${formatNumber(cprData.cp)}</span></div>
                                <div class="level-percent ${cprData.cp > currentPrice ? 'percent-negative' : 'percent-positive'}">${cprData.cp > currentPrice ? '-' : '+'}${Math.abs(((cprData.cp - currentPrice) / currentPrice * 100)).toFixed(2)}%</div>
                            </div>
                            <div class="cpr-level-item cpr-bc">
                                <div>BC: <span class="level-price">$${formatNumber(cprData.bc)}</span></div>
                                <div class="level-percent percent-positive">+${((currentPrice - cprData.bc) / cprData.bc * 100).toFixed(2)}%</div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${cprData.priceVsCPR}% inside CPR range)</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'cpr-inside';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="cpr-details">Calculating Daily CPR using PREVIOUS DAY\'S data...</div>';
            }
            
            cprElement.innerHTML = `
                <span class="cpr-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update Support Convergence cell
        function updateSupportConvergenceCell(symbol, convergenceData) {
            const convergenceElement = document.getElementById(`support-convergence-${symbol}`);
            if (!convergenceElement) return;
            
            let badgeClass = 'support-convergence-no';
            let badgeText = 'No Convergence';
            let detailsHtml = '';
            
            if (convergenceData.status === 'Solid Support') {
                badgeClass = 'support-convergence-yes';
                badgeText = 'Solid Support';
                detailsHtml = `
                    <div class="support-convergence-details">
                        <strong>Convergence Found!</strong><br>
                        Convergence Price: <span class="convergence-price">$${formatNumber(convergenceData.price)}</span><br>
                        Support Type: <span class="swing-price">${convergenceData.supportType}</span><br>
                        CPR Level: <span class="swing-price">${convergenceData.cprType}</span><br>
                        Difference: <span class="percentage">${convergenceData.differencePercent}%</span><br>
                        Support Price: <span class="swing-price">$${formatNumber(convergenceData.supportPrice)}</span><br>
                        <em>Strong support zone identified at convergence point</em>
                    </div>
                `;
            } else {
                badgeClass = 'support-convergence-no';
                badgeText = 'No Convergence';
                detailsHtml = `
                    <div class="support-convergence-details">
                        No convergence between support levels and CPR.<br>
                        Support and CPR levels are more than 0.5% apart.<br>
                        <em>Look for levels within 0.5% for stronger support</em>
                    </div>
                `;
            }
            
            convergenceElement.innerHTML = `
                <span class="support-convergence-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // NEW: Update Resistance Convergence cell
        function updateResistanceConvergenceCell(symbol, convergenceData) {
            const convergenceElement = document.getElementById(`resistance-convergence-${symbol}`);
            if (!convergenceElement) return;
            
            let badgeClass = 'resistance-convergence-no';
            let badgeText = 'No Convergence';
            let detailsHtml = '';
            
            if (convergenceData.status === 'Solid Resistance') {
                badgeClass = 'resistance-convergence-yes';
                badgeText = 'Solid Resistance';
                detailsHtml = `
                    <div class="resistance-convergence-details">
                        <strong>Convergence Found!</strong><br>
                        Convergence Price: <span class="convergence-price">$${formatNumber(convergenceData.price)}</span><br>
                        Resistance Type: <span class="swing-price">${convergenceData.resistanceType}</span><br>
                        CPR Level: <span class="swing-price">${convergenceData.cprType}</span><br>
                        Difference: <span class="percentage">${convergenceData.differencePercent}%</span><br>
                        Resistance Price: <span class="swing-price">$${formatNumber(convergenceData.resistancePrice)}</span><br>
                        <em>Strong resistance zone identified at convergence point</em>
                    </div>
                `;
            } else {
                badgeClass = 'resistance-convergence-no';
                badgeText = 'No Convergence';
                detailsHtml = `
                    <div class="resistance-convergence-details">
                        No convergence between resistance levels and CPR.<br>
                        Resistance and CPR levels are more than 0.5% apart.<br>
                        <em>Look for levels within 0.5% for stronger resistance</em>
                    </div>
                `;
            }
            
            convergenceElement.innerHTML = `
                <span class="resistance-convergence-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update VWAP cell with corrected percentage display
        function updateVWAPCell(symbol, vwapData, currentPrice) {
            const vwapElement = document.getElementById(`vwap-${symbol}`);
            if (!vwapElement) return;
            
            let badgeClass = 'vwap-near';
            let badgeText = 'Near VWAP';
            let detailsHtml = '';
            
            // Helper function to format percentage with correct sign
            function formatVWAPPercentage(value) {
                if (value > 0) return `+${value.toFixed(2)}%`;
                if (value < 0) return `${value.toFixed(2)}%`;
                return `0.00%`;
            }
            
            // Get percentage class based on value
            function getPercentageClass(value) {
                if (value > 0) return 'percent-negative'; // Positive = red (overbought)
                if (value < 0) return 'percent-positive'; // Negative = green (oversold)
                return 'percent-positive';
            }
            
            switch (vwapData.position) {
                case 'above':
                    badgeClass = 'vwap-above';
                    badgeText = 'Above VWAP';
                    detailsHtml = `
                        <div class="vwap-details">
                            <div class="vwap-band-item vwap-upper">
                                <div>Upper Band: <span class="level-price">$${formatNumber(vwapData.upperBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromUpperBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromUpperBand)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-line">
                                <div>VWAP Line: <span class="level-price">$${formatNumber(vwapData.vwap)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromVWAP)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromVWAP)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-lower">
                                <div>Lower Band: <span class="level-price">$${formatNumber(vwapData.lowerBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromLowerBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromLowerBand)}
                                </div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${formatVWAPPercentage(vwapData.distanceFromVWAP)} from VWAP)</em><br>
                            <em>Price is above upper band - statistically overbought</em>
                        </div>
                    `;
                    break;
                case 'below':
                    badgeClass = 'vwap-below';
                    badgeText = 'Below VWAP';
                    detailsHtml = `
                        <div class="vwap-details">
                            <div class="vwap-band-item vwap-upper">
                                <div>Upper Band: <span class="level-price">$${formatNumber(vwapData.upperBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromUpperBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromUpperBand)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-line">
                                <div>VWAP Line: <span class="level-price">$${formatNumber(vwapData.vwap)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromVWAP)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromVWAP)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-lower">
                                <div>Lower Band: <span class="level-price">$${formatNumber(vwapData.lowerBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromLowerBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromLowerBand)}
                                </div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${formatVWAPPercentage(vwapData.distanceFromVWAP)} from VWAP)</em><br>
                            <em>Price is below lower band - statistically oversold</em>
                        </div>
                    `;
                    break;
                case 'near':
                    badgeClass = 'vwap-near';
                    badgeText = 'Near VWAP';
                    detailsHtml = `
                        <div class="vwap-details">
                            <div class="vwap-band-item vwap-upper">
                                <div>Upper Band: <span class="level-price">$${formatNumber(vwapData.upperBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromUpperBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromUpperBand)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-line">
                                <div>VWAP Line: <span class="level-price">$${formatNumber(vwapData.vwap)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromVWAP)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromVWAP)}
                                </div>
                            </div>
                            <div class="vwap-band-item vwap-lower">
                                <div>Lower Band: <span class="level-price">$${formatNumber(vwapData.lowerBand)}</span></div>
                                <div class="level-percent ${getPercentageClass(vwapData.distanceFromLowerBand)}">
                                    ${formatVWAPPercentage(vwapData.distanceFromLowerBand)}
                                </div>
                            </div>
                            <em>Current: <span class="swing-price">$${formatNumber(currentPrice)}</span> (${formatVWAPPercentage(vwapData.distanceFromVWAP)} from VWAP)</em><br>
                            <em>Price near VWAP line - neutral position</em>
                        </div>
                    `;
                    break;
                default:
                    badgeClass = 'vwap-near';
                    badgeText = 'Analyzing...';
                    detailsHtml = '<div class="vwap-details">Calculating VWAP (Session anchor, Source: (H+L+C)/3, Bands: 1 std dev)...</div>';
            }
            
            vwapElement.innerHTML = `
                <span class="vwap-badge ${badgeClass}">${badgeText}</span>
                ${detailsHtml}
            `;
        }
        
        // Update Indicator Summary 1 cell (MACD, Crossover, Ichimoku, EMA, VWAP Line, VWAP Upper, VWAP Lower)
        function updateIndicatorSummary1Cell(symbol, summaryData) {
            const summaryElement = document.getElementById(`indicator-summary1-${symbol}`);
            if (!summaryElement) return;
            
            let html = '<div class="indicator-summary-container">';
            
            // MACD
            let macdColorClass = 'summary-neutral';
            let macdValue = `${summaryData.macd.status}`;
            if (summaryData.macd.status === 'positive') {
                macdColorClass = 'summary-positive';
                macdValue = `Bullish (${formatNumber(summaryData.macd.histogram)})`;
            } else if (summaryData.macd.status === 'negative') {
                macdColorClass = 'summary-negative';
                macdValue = `Bearish (${formatNumber(summaryData.macd.histogram)})`;
            }
            html += `<div class="indicator-summary-item summary-macd ${macdColorClass}">
                <span class="indicator-summary-label">MACD:</span>
                <span class="indicator-summary-value ${macdColorClass}">${macdValue}</span>
            </div>`;
            
            // MACD Crossover
            let crossoverColorClass = 'summary-neutral';
            let crossoverValue = 'None';
            if (summaryData.crossover.type === 'bullish') {
                crossoverColorClass = 'summary-positive';
                crossoverValue = `Bullish (${summaryData.crossover.strength.toFixed(4)})`;
            } else if (summaryData.crossover.type === 'bearish') {
                crossoverColorClass = 'summary-negative';
                crossoverValue = `Bearish (${summaryData.crossover.strength.toFixed(4)})`;
            }
            html += `<div class="indicator-summary-item summary-crossover ${crossoverColorClass}">
                <span class="indicator-summary-label">Crossover:</span>
                <span class="indicator-summary-value ${crossoverColorClass}">${crossoverValue}</span>
            </div>`;
            
            // Ichimoku Cloud
            let ichimokuColorClass = 'summary-neutral';
            let ichimokuValue = `${summaryData.ichimoku.cloudPosition}`;
            if (summaryData.ichimoku.cloudPosition === 'above') {
                ichimokuColorClass = 'summary-positive';
                ichimokuValue = `Above (+${summaryData.ichimoku.priceVsCloud.toFixed(1)}%)`;
            } else if (summaryData.ichimoku.cloudPosition === 'below') {
                ichimokuColorClass = 'summary-negative';
                ichimokuValue = `Below (${summaryData.ichimoku.priceVsCloud.toFixed(1)}%)`;
            }
            html += `<div class="indicator-summary-item summary-ichimoku ${ichimokuColorClass}">
                <span class="indicator-summary-label">Ichimoku:</span>
                <span class="indicator-summary-value ${ichimokuColorClass}">${ichimokuValue}</span>
            </div>`;
            
            // EMA Position
            let emaColorClass = 'summary-neutral';
            let emaValue = `${summaryData.ema.position}`;
            if (summaryData.ema.position === 'above') {
                emaColorClass = 'summary-positive';
                emaValue = `Above (+${summaryData.ema.differencePercentage.toFixed(1)}%)`;
            } else if (summaryData.ema.position === 'below') {
                emaColorClass = 'summary-negative';
                emaValue = `Below (${summaryData.ema.differencePercentage.toFixed(1)}%)`;
            }
            html += `<div class="indicator-summary-item summary-ema ${emaColorClass}">
                <span class="indicator-summary-label">EMA:</span>
                <span class="indicator-summary-value ${emaColorClass}">${emaValue}</span>
            </div>`;
            
            // VWAP Line
            let vwapLineColorClass = 'summary-info';
            let vwapLineValue = `${summaryData.vwap.distanceFromVWAP >= 0 ? '+' : ''}${summaryData.vwap.distanceFromVWAP.toFixed(2)}%`;
            if (summaryData.vwap.position === 'above') {
                vwapLineColorClass = 'summary-negative'; // Above VWAP = overbought (red)
                vwapLineValue = `Above (+${summaryData.vwap.distanceFromVWAP.toFixed(2)}%)`;
            } else if (summaryData.vwap.position === 'below') {
                vwapLineColorClass = 'summary-positive'; // Below VWAP = oversold (green)
                vwapLineValue = `Below (${summaryData.vwap.distanceFromVWAP.toFixed(2)}%)`;
            }
            html += `<div class="indicator-summary-item summary-vwap ${vwapLineColorClass}">
                <span class="indicator-summary-label">VWAP Line:</span>
                <span class="indicator-summary-value ${vwapLineColorClass}">${vwapLineValue}</span>
            </div>`;
            
            // VWAP Upper Band
            let vwapUpperColorClass = 'summary-info';
            let vwapUpperValue = `${summaryData.vwap.distanceFromUpperBand >= 0 ? '+' : ''}${summaryData.vwap.distanceFromUpperBand.toFixed(2)}%`;
            if (summaryData.vwap.distanceFromUpperBand > 0) {
                vwapUpperColorClass = 'summary-negative'; // Positive = above upper band = overbought
                vwapUpperValue = `Above UB (+${summaryData.vwap.distanceFromUpperBand.toFixed(2)}%)`;
            } else if (summaryData.vwap.distanceFromUpperBand < 0) {
                vwapUpperColorClass = 'summary-positive'; // Negative = below upper band = normal/oversold
                vwapUpperValue = `Below UB (${summaryData.vwap.distanceFromUpperBand.toFixed(2)}%)`;
            } else {
                vwapUpperValue = `At UB (0.00%)`;
            }
            html += `<div class="indicator-summary-item summary-vwap ${vwapUpperColorClass}">
                <span class="indicator-summary-label">VWAP Upper:</span>
                <span class="indicator-summary-value ${vwapUpperColorClass}">${vwapUpperValue}</span>
            </div>`;
            
            // VWAP Lower Band
            let vwapLowerColorClass = 'summary-info';
            let vwapLowerValue = `${summaryData.vwap.distanceFromLowerBand >= 0 ? '+' : ''}${summaryData.vwap.distanceFromLowerBand.toFixed(2)}%`;
            if (summaryData.vwap.distanceFromLowerBand > 0) {
                vwapLowerColorClass = 'summary-negative'; // Positive = above lower band = normal/overbought
                vwapLowerValue = `Above LB (+${summaryData.vwap.distanceFromLowerBand.toFixed(2)}%)`;
            } else if (summaryData.vwap.distanceFromLowerBand < 0) {
                vwapLowerColorClass = 'summary-positive'; // Negative = below lower band = oversold
                vwapLowerValue = `Below LB (${summaryData.vwap.distanceFromLowerBand.toFixed(2)}%)`;
            } else {
                vwapLowerValue = `At LB (0.00%)`;
            }
            html += `<div class="indicator-summary-item summary-vwap ${vwapLowerColorClass}">
                <span class="indicator-summary-label">VWAP Lower:</span>
                <span class="indicator-summary-value ${vwapLowerColorClass}">${vwapLowerValue}</span>
            </div>`;
            
            html += '</div>';
            
            summaryElement.innerHTML = html;
        }
        
        // Update Indicator Summary 2 cell (Volume, OBV, Support, Flipped Support, Liquidity Grab Support, Resistance, Flipped Res, Liquidity Grab Resistance)
        function updateIndicatorSummary2Cell(symbol, summaryData) {
            const summaryElement = document.getElementById(`indicator-summary2-${symbol}`);
            if (!summaryElement) return;
            
            let html = '<div class="indicator-summary-container">';
            
            // Volume Spike
            let volumeColorClass = summaryData.volumeSpike.spike ? 'summary-info' : 'summary-neutral';
            let volumeValue = summaryData.volumeSpike.spike ? `${summaryData.volumeSpike.multiple}x Spike` : 'Normal';
            html += `<div class="indicator-summary-item summary-volume ${volumeColorClass}">
                <span class="indicator-summary-label">Volume:</span>
                <span class="indicator-summary-value ${volumeColorClass}">${volumeValue}</span>
            </div>`;
            
            // OBV
            let obvColorClass = 'summary-neutral';
            let obvValue = `${summaryData.obv.trend}`;
            if (summaryData.obv.trend === 'rising') {
                obvColorClass = 'summary-positive';
                obvValue = `Rising (+${summaryData.obv.obvChange.toFixed(1)}%)`;
            } else if (summaryData.obv.trend === 'falling') {
                obvColorClass = 'summary-negative';
                obvValue = `Falling (${summaryData.obv.obvChange.toFixed(1)}%)`;
            }
            html += `<div class="indicator-summary-item summary-obv ${obvColorClass}">
                <span class="indicator-summary-label">OBV:</span>
                <span class="indicator-summary-value ${obvColorClass}">${obvValue}</span>
            </div>`;
            
            // Support Levels (Percentage only)
            let supportColorClass = 'summary-neutral';
            let supportValue = 'None';
            if (summaryData.supportLevels.hasLevels) {
                supportColorClass = summaryData.supportLevels.percentage >= 0 ? 'summary-positive' : 'summary-negative';
                supportValue = `${summaryData.supportLevels.percentage >= 0 ? '+' : ''}${summaryData.supportLevels.percentage.toFixed(2)}%`;
            }
            html += `<div class="indicator-summary-item summary-support ${supportColorClass}">
                <span class="indicator-summary-label">Support:</span>
                <span class="indicator-summary-value ${supportColorClass}">${supportValue}</span>
            </div>`;
            
            // Flipped Support (Percentage only)
            let flippedColorClass = 'summary-neutral';
            let flippedValue = 'None';
            if (summaryData.flippedSupport.hasLevels) {
                flippedColorClass = summaryData.flippedSupport.percentage >= 0 ? 'summary-positive' : 'summary-negative';
                flippedValue = `${summaryData.flippedSupport.percentage >= 0 ? '+' : ''}${summaryData.flippedSupport.percentage.toFixed(2)}%`;
            }
            html += `<div class="indicator-summary-item summary-flipped ${flippedColorClass}">
                <span class="indicator-summary-label">Flipped S:</span>
                <span class="indicator-summary-value ${flippedColorClass}">${flippedValue}</span>
            </div>`;
            
            // Liquidity Grab Support
            let liquiditySupportColorClass = 'summary-neutral';
            let liquiditySupportValue = 'No';
            if (summaryData.liquidityGrabSupport.detected) {
                liquiditySupportColorClass = 'summary-positive';
                liquiditySupportValue = 'Yes';
            }
            html += `<div class="indicator-summary-item summary-liquidity-support ${liquiditySupportColorClass}">
                <span class="indicator-summary-label">Liquidity S:</span>
                <span class="indicator-summary-value ${liquiditySupportColorClass}">${liquiditySupportValue}</span>
            </div>`;
            
            // Resistance Levels (Percentage only)
            let resistanceColorClass = 'summary-neutral';
            let resistanceValue = 'None';
            if (summaryData.resistanceLevels.hasLevels) {
                resistanceColorClass = summaryData.resistanceLevels.percentage >= 0 ? 'summary-negative' : 'summary-positive';
                resistanceValue = `${summaryData.resistanceLevels.percentage >= 0 ? '+' : ''}${summaryData.resistanceLevels.percentage.toFixed(2)}%`;
            }
            html += `<div class="indicator-summary-item summary-resistance ${resistanceColorClass}">
                <span class="indicator-summary-label">Resistance:</span>
                <span class="indicator-summary-value ${resistanceColorClass}">${resistanceValue}</span>
            </div>`;
            
            // Flipped Resistance (Percentage only)
            let flippedResistanceColorClass = 'summary-neutral';
            let flippedResistanceValue = 'None';
            if (summaryData.flippedResistance.hasLevels) {
                flippedResistanceColorClass = summaryData.flippedResistance.percentage >= 0 ? 'summary-negative' : 'summary-positive';
                flippedResistanceValue = `${summaryData.flippedResistance.percentage >= 0 ? '+' : ''}${summaryData.flippedResistance.percentage.toFixed(2)}%`;
            }
            html += `<div class="indicator-summary-item summary-flipped-resistance ${flippedResistanceColorClass}">
                <span class="indicator-summary-label">Flipped R:</span>
                <span class="indicator-summary-value ${flippedResistanceColorClass}">${flippedResistanceValue}</span>
            </div>`;
            
            // Liquidity Grab Resistance
            let liquidityResistanceColorClass = 'summary-neutral';
            let liquidityResistanceValue = 'No';
            if (summaryData.liquidityGrabResistance.detected) {
                liquidityResistanceColorClass = 'summary-negative';
                liquidityResistanceValue = 'Yes';
            }
            html += `<div class="indicator-summary-item summary-liquidity-resistance ${liquidityResistanceColorClass}">
                <span class="indicator-summary-label">Liquidity R:</span>
                <span class="indicator-summary-value ${liquidityResistanceColorClass}">${liquidityResistanceValue}</span>
            </div>`;
            
            html += '</div>';
            
            summaryElement.innerHTML = html;
        }
        
        // Update Indicator Summary 3 cell (CPR-TC, CPR-CP, CPR-BC, Correlation with BTC, Support Convergence with CPR, Resistance Convergence with CPR, ATR)
        function updateIndicatorSummary3Cell(symbol, summaryData) {
            const summaryElement = document.getElementById(`indicator-summary3-${symbol}`);
            if (!summaryElement) return;
            
            let html = '<div class="indicator-summary-container">';
            
            // CPR-TC
            let cprTcColorClass = 'summary-info';
            let cprTcValue = `${summaryData.cpr.tcPercentage >= 0 ? '+' : ''}${summaryData.cpr.tcPercentage.toFixed(1)}%`;
            html += `<div class="indicator-summary-item summary-cpr ${cprTcColorClass}">
                <span class="indicator-summary-label">CPR-TC:</span>
                <span class="indicator-summary-value ${cprTcColorClass}">${cprTcValue}</span>
            </div>`;
            
            // CPR-CP
            let cprCpColorClass = 'summary-info';
            let cprCpValue = `${summaryData.cpr.cpPercentage >= 0 ? '+' : ''}${summaryData.cpr.cpPercentage.toFixed(1)}%`;
            html += `<div class="indicator-summary-item summary-cpr ${cprCpColorClass}">
                <span class="indicator-summary-label">CPR-CP:</span>
                <span class="indicator-summary-value ${cprCpColorClass}">${cprCpValue}</span>
            </div>`;
            
            // CPR-BC
            let cprBcColorClass = 'summary-info';
            let cprBcValue = `${summaryData.cpr.bcPercentage >= 0 ? '+' : ''}${summaryData.cpr.bcPercentage.toFixed(1)}%`;
            html += `<div class="indicator-summary-item summary-cpr ${cprBcColorClass}">
                <span class="indicator-summary-label">CPR-BC:</span>
                <span class="indicator-summary-value ${cprBcColorClass}">${cprBcValue}</span>
            </div>`;
            
            // Correlation with BTC
            let correlationColorClass = 'summary-neutral';
            let correlationValue = `${summaryData.correlation.percentage.toFixed(1)}%`;
            if (summaryData.correlation.strength === 'low') {
                correlationColorClass = 'summary-positive'; // Low correlation = more independent (green)
                correlationValue = `Low (${summaryData.correlation.percentage.toFixed(1)}%)`;
            } else if (summaryData.correlation.strength === 'medium') {
                correlationColorClass = 'summary-neutral'; // Medium correlation = neutral (yellow)
                correlationValue = `Medium (${summaryData.correlation.percentage.toFixed(1)}%)`;
            } else if (summaryData.correlation.strength === 'high') {
                correlationColorClass = 'summary-negative'; // High correlation = follows BTC (red)
                correlationValue = `High (${summaryData.correlation.percentage.toFixed(1)}%)`;
            }
            html += `<div class="indicator-summary-item summary-correlation ${correlationColorClass}">
                <span class="indicator-summary-label">Correlation:</span>
                <span class="indicator-summary-value ${correlationColorClass}">${correlationValue}</span>
            </div>`;
            
            // Support Convergence with CPR
            let supportConvergenceColorClass = 'summary-neutral';
            let supportConvergenceValue = 'No';
            if (summaryData.supportConvergence.status === 'Solid Support') {
                supportConvergenceColorClass = 'summary-positive';
                supportConvergenceValue = 'Yes';
            }
            html += `<div class="indicator-summary-item summary-convergence ${supportConvergenceColorClass}">
                <span class="indicator-summary-label">Conv. S-CPR:</span>
                <span class="indicator-summary-value ${supportConvergenceColorClass}">${supportConvergenceValue}</span>
            </div>`;
            
            // NEW: Resistance Convergence with CPR
            let resistanceConvergenceColorClass = 'summary-neutral';
            let resistanceConvergenceValue = 'No';
            if (summaryData.resistanceConvergence.status === 'Solid Resistance') {
                resistanceConvergenceColorClass = 'summary-negative';
                resistanceConvergenceValue = 'Yes';
            }
            html += `<div class="indicator-summary-item summary-resistance-convergence ${resistanceConvergenceColorClass}">
                <span class="indicator-summary-label">Conv. R-CPR:</span>
                <span class="indicator-summary-value ${resistanceConvergenceColorClass}">${resistanceConvergenceValue}</span>
            </div>`;
            
            // ATR
            let atrColorClass = 'summary-neutral';
            let atrValue = `${summaryData.atr.volatility} (${summaryData.atr.atrPercentage}%)`;
            if (summaryData.atr.volatility === 'high') {
                atrColorClass = 'summary-negative'; // High volatility = risky (red)
            } else if (summaryData.atr.volatility === 'moderate') {
                atrColorClass = 'summary-neutral'; // Moderate volatility = neutral (yellow)
            } else if (summaryData.atr.volatility === 'good') {
                atrColorClass = 'summary-positive'; // Good volatility = ideal (green)
            } else if (summaryData.atr.volatility === 'low') {
                atrColorClass = 'summary-neutral'; // Low volatility = neutral (yellow)
            }
            html += `<div class="indicator-summary-item summary-atr ${atrColorClass}">
                <span class="indicator-summary-label">ATR:</span>
                <span class="indicator-summary-value ${atrColorClass}">${atrValue}</span>
            </div>`;
            
            html += '</div>';
            
            summaryElement.innerHTML = html;
        }
        
        // Format numbers with commas (for prices)
        function formatNumber(num) {
            if (num === 0 || !num) return '0.00';
            
            if (Math.abs(num) < 0.01) {
                return num.toFixed(6);
            }
            
            if (Math.abs(num) < 1000) {
                return num.toFixed(4);
            }
            
            return num.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
        }
        
        // Format large numbers (for volumes and OBV)
        function formatLargeNumber(num) {
            if (num === 0 || !num) return '0';
            
            if (Math.abs(num) >= 1000000000) {
                return (num / 1000000000).toFixed(2) + 'B';
            } else if (Math.abs(num) >= 1000000) {
                return (num / 1000000).toFixed(2) + 'M';
            } else if (Math.abs(num) >= 1000) {
                return (num / 1000).toFixed(2) + 'K';
            } else {
                return num.toFixed(2);
            }
        }
        
        // Show error message
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('show');
        }
        
        // Clear error message
        function clearError() {
            errorMessage.classList.remove('show');
        }
    </script>
</body>
</html>